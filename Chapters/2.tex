%!TEX root = ../main.tex
En este capítulo comenzamos la segunda parte de las notas de clase, en estas secciones resaltamos que no hay una única solución a los ejercicios y que algunas de las soluciones pueden llegar a ser redundantes, sin embargo son funcionales y esto es lo que más nos interesa.

\section{Expresiones regulares}

\textbf{Punto 1: }Encontrar expresiones regulares para los siguientes lenguajes definidos sobre el alfabeto $\Sigma=\{a,b\}:$

\begin{itemize}

    \item[$\bullet$] Lenguaje de todas las cadena que comienzan con el símbolo $b$ y terminan con el símbolo $a$.\\ 

    La solución más evidente es la siguiente: $b(a\cup b)^*a$, con $(a\cup b)^*$ consideramos todas las cadenas y lo que hacemos es forzar que las cadenas comiencen con $b$ y terminen en $a$ concatenando.

    \item[$\bullet$]Lenguaje de todas las cadenas de longitud impar.\\

     Sabemos que para generar todas las cadenas de longitud par usamos $(aa\cup bb\cup ab\cup ba)^*=((a\cup b)(a\cup b))^*$, luego para generar las impares debemos considerar 4 casos y unirlos:

    $$a((a\cup b)(a\cup b))^*\cup b((a\cup b)(a\cup b))^* \cup ((a\cup b)(a\cup b))^*a \cup ((a\cup b)(a\cup b))^*b$$

    Esto convierte las cadenas pares en impares siempre y considera los casos en que comience por $a$ o por $b$ o termine por $a$ o $b$ (se puede llegar a una solución mejor quizá).

    \item[$\bullet$] Lenguaje de todas las cadenas que tienen un numero impar de $aes.$\\ 

    Sabemos que $(b^*ab^*ab^*)^*$ genera todas las cadenas con un número par (mayor que 0) de $aes$, luego usando este hecho construimos:

    $$a(b^*ab^*ab^*)^*\cup (b^*ab^*ab^*)^*a$$

    y acabamos.

    \item[$\bullet$]Lenguaje de todas las cadenas en las que el numero de $bes$ es un múltiplo $\geq0$ de 3.\\ 

    Sabemos generar las cadenas de $a$ y $b$ que contienen un número par de $a$ o $b$, la solución está propuesta en las notas de clase, luego cambiamos un poco la expresión de esta forma:

    $$a^*(a^*ba^*ba^*ba^*)^*$$

    La expresión $a^*(ba^*ba^*b)^*a^*$ también es una solución.

    \item[$\bullet$] Lenguaje de todas las cadenas que no comienzan con la subcadena $ba$ ni terminan en $b.$\\ 

    Para este caso las cadenas pueden comenzar por $a$, $ab$, $b^2$, $a^2$, luego obtenemos la expresión:

    $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a $$

    Ya que tampoco pueden acabar en $b$, ahora no falta notas que por agregar esta $a$ al final y la expresión $(a\cup ab \cup b^2 \cup a^2)$ es imposible obtener la cadena vacía y la cadena $a$, pues las añadimos y nos queda finalmente:

     $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a \cup a \cup \lambda$$

     \item[$\bullet$] Lenguaje de todas las cadenas que no contienen la subcadena $bba.$\\ 

     Para la expresión regular en este caso notemos que toda cadena tiene bloques de la forma $ba$ donde estos van intercalados con un numero de $a$ arbitrarias así obtenemos la expresión:

     $$(a\cup ba)^*$$

     Observe que las $b$ están restringidas ya que para $b\geq 2$ las cadenas de este estilo no pueden tener una $a$ luego de la cantidad arbitraria de $bes$, pero esta expresión no contempla las cadenas del estilo $bb\dots b$, para esto basta concatenar estas cadenas al final, obteniendo finalmente la expresión:

     $$(a\cup ba)^*b^*$$

\end{itemize}

\textbf{Punto 2: } Encontrar expresiones regulares para los siguientes lenguajes definidos sobre el alfabeto $\Sigma=\{0,1,2\}:$

\begin{itemize}
    \item[$\bullet$] Lenguaje de todas las cadenas que comienzan con 2 y terminan con 1.\\ 

    Al igual que en el primer ítem del punto anterior, lo mas natural es forzar que la cadena empiece en con $2$ y termine en $1$, concatenando respectivamente obtenemos la expresión $2(0\cup1\cup2)^*1$.

    \item[$\bullet$] Lenguaje de todas las cadenas que no comienzan con 2 ni terminan en 1.\\ 

    Similar a la construcción anterior podemos forzar a que las cadenas no empiecen con $2$ ni terminen con $1$ concatenando $(0\cup1)$ y $(0\cup2)$ respectivamente. De esta forma obtenemos la expresión:
    
    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)$$

    Note que en el lenguaje propuesto las cadenas $\lambda$ y $0$ también cumplen la condición, pero es imposible generarlas por medio de la expresión dada. Afortunadamente arreglar esto es sencillo ya que podemos agregarlas por medio de uniones, obteniendo así:

    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)\cup\lambda\cup0$$

    \item[$\bullet$] Lenguaje de todas las cadenas que tienen exactamente dos ceros.\\ 

    Nuevamente la forma mas natural de construir la expresión que represente al lenguaje es forzando que aparezcan solo $2$ ceros, tenga en cuenta que los ceros pueden estar en cualquier posición y por tanto la expresión es la siguiente $(1\cup2)^*0(1\cup2)^*0(1\cup2)^*$.

    \item[$\bullet$] Lenguaje de todas las cadenas que tienen un numero par de símbolos.\\

     Ya sabemos como generar los bloques de dos elementos de un lenguaje, para este caso $(0\cup1\cup2)(0\cup1\cup2)=(0\cup1\cup2)^2$, luego de esto basta concatenar estos bloques de todas la formas posibles, obteniendo así la expresión:

    $$\left((0\cup1\cup2)^2\right)^*$$

    \item[$\bullet$] Lenguaje de todas las cadenas que tienen un numero impar de símbolos.\\

     Usando la expresión del ítem anterior, si concatenamos al final $0$,$1$ o $2$ obtenemos las cadenas de longitud impar, es decir:
    
    $$\left((0\cup1\cup2)^2\right)^*(0\cup1\cup2)$$

    \item[$\bullet$] Lenguaje de todas las cadenas que no contienen dos unos consecutivos.\\ 

    Como no pueden aparecer dos unos consecutivos, las cadenas contienen bloques de la forma $(0\cup2)1(0\cup2)$, y junto a ellas cantidades arbitrarias de ceros y dos alternados:

    $$(0\cup2\cup(0\cup2)1(0\cup2))^*$$

    Observe que si bien esta expresión nos da múltiples cadenas aun hay varias que no genera. Por ejemplo no genera cadenas que empiecen o terminen en $1$. Esto podemos agregarlo concatenado $1\cup\lambda$ al inicio y final de la expresión:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)$$

    La cadena $\lambda$ es de vital importancia en la expresión ya que esta nos permite concatenar sin perder las cadenas que ya teníamos previamente. Además note que en la expresión cambiamos la $*$ por un $+$, esto se debe a que si no realizamos este cambio generaríamos la cadena $11$ y esta no cumple los criterios del lenguaje, por ultimo las cadenas $\lambda$ y $1$ cumplen las condiciones, mas no pueden ser generadas por lo que solo queda agregarlas y así obtener la expresión final:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)\cup\lambda\cup1$$
\end{itemize}

\textbf{Punto 3: } Encontrar expresiones regulares para los siguientes lenguajes definidos sobre el alfabeto $\Sigma=\{0,1\}:$

\begin{itemize}
    \item[$\bullet$] Lenguaje de todas las cadenas que tienen por lo menos un 0 y por lo menos un 1.\\ 

    Para que una cadena tenga al menos un $0$ y un $1$ debe ser mínimo un bloque $01$ o un bloque $10$, luego simplemente fijamos esas dos posibilidades para que la solución sea  $(0\cup1)^*(01\cup10)(0\cup1)^*$.

    \item[$\bullet$] Lenguaje de todas las cadenas que no contienen tres ceros consecutivos.\\ 

    La condición nos indica que en las cadenas solo pueden haber uno o dos ceros consecutivos, es decir las forman bloque de la forma $01$ o $001$, luego podemos generar la expresión:

    $$(1\cup01\cup001)^*$$

    Note que esta  no contempla cadenas que terminen en uno o dos ceros, pero esto lo podemos arreglar fácilmente concatenando lo necesario:

    $$(1\cup01\cup001)^*(\lambda\cup0\cup00)$$

    \item[$\bullet$] Lenguaje de todas las cadenas cuya longitud es $\geq4.$\\ 

    Para esta solución simplemente consideremos las cadenas de longitud $4$ es decir las que son generadas por $(0\cup1)^4$, luego como estas son las mínimas cadenas que acepta el lenguaje solo queda hacer que aparezcan las demás posibilidades así $(0\cup1)^4(0\cup1)^*$.

    \item[$\bullet$] Lenguaje de todas las cadenas cuya longitud es $\geq5$ y cuyo quinto símbolo, de izquierda a derecha, es un 1.\\ 

    Note que al forzar que el quinto símbolo de izquierda a derecha sea un $1$ en todas las cadenas básicamente podemos rehusar la solución anterior forzando la condición de esta forma $(0\cup1)^41(0\cup1)^*$.

    \item[$\bullet$] Lenguaje de todas las cadenas que no terminan en 01.\\ 

    Si la cadena no puede terminar en $01$ forzosamente tiene que terminar en $00,10$ o $11$, forzando estas obtenemos:

    $$(0\cup1)^*(00\cup10\cup11)$$

    Observe que esta expresión solo genera cadenas de longitud $\geq2$ pero las cadenas $\lambda,0$ y $1$ cumplen la condición, entonces:

    $$(0\cup1)^*(00\cup10\cup11)\cup\lambda\cup0\cup1$$

    De esta forma terminamos.

    \item[$\bullet$] Lenguaje de todas las cadenas de longitud par $\geq2$ formadas por ceros y unos alternados.\\ 

    Como son cadenas de longitud par, pueden ser formadas por bloques de la forma $01$ o de la forma $10$ luego la solución luce de esta forma $(01)^+\cup(10)^+$. Note que usamos $+$ ya que la cadena $\lambda$ no es aceptada en este lenguaje.

    \item[$\bullet$] Lenguaje de todas las cadenas de longitud $\geq2$ formadas por ceros y unos alternados.\\ 

    Como en el ejercicio anterior ya construimos las cadenas pares, solo nos queda construir todas las impares. Esto lo logramos por medio de concatenar un elemento mas a las expresiones que ya tenemos. La solución luce de la siguiente forma:

    $$(1\cup\lambda)(01)^+\cup(0\cup\lambda)(10)^+$$

    \item[$\bullet$] Lenguaje de todas las cadenas que no contienen dos ceros consecutivos ni dos unos consecutivos.\\ 

    Note que si no pueden haber dos ceros seguidos ni dos unos seguidos, los ceros y los unos deben de ir alternados forzosamente, es decir que la solución es la misma que la del ejercicio previo, exceptuando un detalle:

     $$(1\cup\lambda)(01)^*\cup(0\cup\lambda)(10)^*$$

     Observe que cambiamos el $+$ por una $*$, esto se debe a que las cadenas $\lambda,0$ y $1$ si son validas en este lenguaje.

     \item[$\bullet$] Lenguaje de todas las cadenas de longitud impar que tienen unos en todas y cada una de las posiciones impares; en las posiciones pares pueden aparecer ceros o unos.\\

     Como la cadena tiene que ser impar la de mínima aceptación es la cadena 1. Ahora note que como nos restringimos a que en la posición impar siempre hayan unos, la cadena solo va a tener bloques de la forma 01 o 11. Así la expresión seria $1(01\cup11)^*$.

     \item[$\bullet$] Lenguaje de todas las cadenas cuya longitud es un múltiplo de tres.\\

     Para generar cadenas cuya longitud es un múltiplo de 3, necesitamos todos los bloques de longitud $3$ y posteriormente los concatenamos de todas las formas posibles, es decir tenemos la expresión $\left((0\cup1)^3\right)^*$. Recuerde que $0$ es múltiplo de $3$ por eso usamos el $*$ para asegurar la cadena $\lambda$.

      \item[$\bullet$] Lenguaje de todas las cadenas que no contienen cuatro ceros consecutivos.\\

       Esta expresión sigue un análisis muy similar al de las cadenas donde no podían haber tres ceros consecutivos, de esta forma solo falta agregar los bloques $0001$ y $000$ respectivamente a la expresión que habíamos obtenido:

      $$(1\cup01\cup001\cup0001)^*(\lambda\cup0\cup00\cup000)$$

      \item[$\bullet$] Lenguaje de todas las cadenas que no comienzan con 00 ni terminan en 11.\\

       Observe que la cadena tiene que empezar por $1$ o $01$ y de forma similar tiene que acabar en $0$ o en $01$. Forzando estos símbolos obtenemos:

      $$(1\cup01)(0\cup1)^*(0\cup01)$$

      Ahora como usualmente ha ocurrido a lo largo de esta sección, al forzar cadenas en la expresión, no generamos cadenas que si son aceptadas dentro del lenguaje, pero basta con simplemente agregarlas:

      $$(1\cup01)(0\cup1)^*(0\cup01)\cup\lambda\cup0\cup1\cup01$$

      \item[$\bullet$] Lenguaje de todas las cadenas que no contienen la subcadena 101.\\

       Para que no contengan la subcadena $101$ note que se debe forzar que en todas las expresiones aparezcan al menos dos ceros entre dos unos, las cadenas de este estilo se consiguen por medio de la expresión:

      $$(1\cup00^+)^*$$

      Uno podría verse tentado en pensar que esta es la solución, pero observe que esta expresión no contempla cadenas que empiecen por $01$ y que son totalmente validas, además tampoco contempla cadenas que terminen en un solo cero:

      $$(01\cup\lambda)(1\cup00^+)^*(0\cup\lambda)$$

      Luego de este arreglo si podemos asegurar que están todas las cadenas.
  
\end{itemize}

\textbf{Punto 4: }Sea $\Sigma=\{a,b\}$. Encontrar una expresión regular que represente el lenguaje de todas las cadenas que tienen un numero para $\geq0$ de $aes$ y un numero par $\geq0$ de $bes.$\\

Para este ejercicio no logramos hallar la expresión por mera inspección, pero para no dejar un mal sabor de boca mostraremos la expresión obtenida usando uno de los procedimientos presentados en secciones futuras:
$$[a^2\cup b^2\cup(ab\cup ba)(a^2\cup b^2)^*(ba\cup ab)]^*$$

\hfill $\blacklozenge$

\section{Diseño de autómatas}


Al igual que en la sección anterior las soluciones de este capitulo no son únicas y puede que algunas sean redundantes, además otra aclaración de vital importancia es que todos los autómatas presentados no muestran sus estados limbo, es decir presentaremos AFD simplificados.\\

\textbf{Punto 1: }Sea $\Sigma=\{a,b\}.$ Diseñar AFD que acepten los siguientes lenguajes:
\begin{itemize}[label={$\bullet$}]
    \item $a^*b^*$\\

     Como la cadena mínima es $\lambda$ entonces el estado inicial tiene que ser de aceptación, luego como también se aceptan $aes$ arbitrarias estas pueden ser aceptadas por medio de un bucle. Apenas aparezca una $b$ el autómata cambiara de estado pero ese seria también de aceptación, incluyendo un bucle para las $bes$ arbitrarias:\\
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \path [thick]
            (q0) edge [loop above] node {$a$} ()
            (q0) edge node [above] {$b$} (q1)
            (q1) edge [loop above] node {$b$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item $a^*\cup b^*$\\

     Nuevamente el estado inicial es de aceptación ya que $\lambda$ pertenece a el lenguaje, luego basta con tomar dos caminos para el caso donde sean cadenas de $aes$ y el de cadenas de $bes$:

      
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$a$} (q1)
            (q0) edge [bend right] node [below left] {$b$} (q2)
            (q1) edge [loop above] node {$a$} ()
            (q2) edge [loop below] node {$b$} ();
        \end{tikzpicture}    
    \end{basedtikz}

    \item $(ab)^*$\\

     Note que todas las cadenas de este lenguaje son de la forma $ab\dots ab$, es decir siempre son bloques $ab$ y todas las cadenas empiezan en $a$ y terminan en $b$:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$b$} (q0);
        \end{tikzpicture}
    \end{basedtikz}

    \item $(ab)^+$\\

     Bastante similar a la anterior excepto que la cadena mínima aceptada es $ab$ debido al $+$, así que forzamos esa cadena:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, right of=q1] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q1);
        \end{tikzpicture}     
    \end{basedtikz}

    \item $ab^*\cup b^*a$\\

     Note que debido a la expresión se forman dos caminos, uno son las cadenas que empiezan por $a$ y luego tienen una cantidad de $bes$ arbitrarias. El otro son aquellas que comienzan por un numero de $bes$ arbitrarias pero están forzadas a terminar en $a$ para ser aceptadas:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, below right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q0] {$q_2$};
            \node (q3) [state,  below right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$b$} (q2)
            (q0) edge [bend right] node [below left] {$a$} (q1)
            (q1) edge [loop below] node [below] {$b$} ()
            (q2) edge [loop above] node [above] {$b$} ()
            (q2) edge [bend left] node [above right] {$a$} (q3);
        \end{tikzpicture}
    \end{basedtikz}

    \item $a(a\cup ab)^*$ Observe que las cadena mínima de este lenguaje tiene una sola $a$ así que el estado inicial no es de aceptación, luego note que en ambos casos de la $*$ el elemento es una $a$, por lo que forzamos dos $aes$ y posteriormente realizamos respectivamente el bucle de $aes$ y de $abes$:

    \begin{basedtikz}
    \centering
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, right of=q0, accepting] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \path[thick]
                (q0) edge node [above] {$a$} (q1)
                (q1) edge [bend left] node [above] {$a$} (q2)
                (q2) edge [loop above] node [above] {$a$} ()
                (q2) edge [bend left] node [below] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
     
    \item $a^+b^*a.$ Un AFD  que acepte este lenguaje requiere como mínimo 5 estados mas un estado limbo.\\

    Observe que la cadena mínima es $aa$ entonces debemos forzar ese camino. Ahora note que en ese camino podemos generar el bucle para $a^+$. Note que hay dos posibilidades para las $bes$, o inicia la cadena con solo una $a$ y luego tiene una cantidad arbitraria de $bes$ o empieza con $aes$ arbitrarias y luego tiene $bes$ arbitrarias, pero note que siempre que aparece al menos una $b$ la cadena siempre acaba en $a$:
     
    \begin{basedtikz}
    \centering
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, below right of=q1] {$q_2$};
            \node (q3) [state, above right of=q1] {$q_3$};
            \node (q4) [state, accepting, below right of=q3] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q1) edge [bend right] node [below] {$a$} (q2)
            (q2) edge [loop below] node [below] {$a$} ()
            (q2) edge node [right] {$b$} (q3)
            (q3) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [above] {$a$} (q4);
        \end{tikzpicture}
    \end{basedtikz}

    \item $a^*b\cup b^*a.$ Un AFD  que acepte este lenguaje requiere como mínimo 6 estados mas un estado limbo.\\

     Primero notemos que las cadenas mínimas son $a$ y $b$, así que debemos forzar dos caminos que las acepten. Ahora observe que si sale una $a$ existen dos posibilidades, es seguida inmediatamente de una $b$ o salen $aes$ arbitrarias y luego si una $b$. Note que este análisis también es valido respectivamente con $b$:

        \begin{basedtikz}
        \centering
            \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q5) [state, below right of=q1, accepting] {$q_5$};
            \node (q2) [state, above right of=q5] {$q_2$};
            \node (q3) [state, below right of=q0, accepting] {$q_3$};
            \node (q4) [state, below right of=q5] {$q_4$};
            
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q0) edge [bend right] node [below] {$b$} (q3)
            (q1) edge node [above] {$a$} (q2)
            (q3) edge node [below] {$b$} (q4)
            (q2) edge [loop above] node [above] {$a$} ()
            (q4) edge [loop below] node [below] {$b$} ()
            (q2) edge node [below] {$b$} (q5)
            (q4) edge node [above] {$a$} (q5)
            (q1) edge node [below] {$b$} (q5)
            (q3) edge node [above] {$a$} (q5);     
            \end{tikzpicture}
        \end{basedtikz}

        \item $b^*(ab\cup ba)$\\ 

        Observe que nuestras dos cadenas mínimas de aceptación son $ab$ y $ba$ así que forzamos esos dos caminos. Posteriormente para hacer que aparezcan las $bes$ arbitrarias podemos agregar un bucle en el camino donde generamos $ba$. Si lo dejáramos hasta ahí nos faltarían las cadenas de la forma $b^*ab$ pero esto se arregla fácilmente conectando el camino de $ba$ al de $ab$ colocando una $b$ entre estados de aceptación:
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3, accepting] {$q_4$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2);
            \end{tikzpicture}
        \end{basedtikz}

        \item $b^*(ab\cup ba)a^+$\\

         Note que el lenguaje es muy parecido a excepción de que las cadenas forzosamente acaban en por lo menos una $a$, pero lo que podemos hacer es usar el autómata construido previamente y aquellos estados de aceptación forzamos que salga una $a$ hacia un nuevo estado de aceptación que generara la concatenación de $a^+$:

        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3] {$q_4$};
                \node (q5) [state, above right of=q4, accepting] {$q_5$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2)
                (q2) edge [bend left] node [above] {$a$} (q5)
                (q4) edge [bend right] node [below] {$a$} (q5)
                (q5) edge [loop right] node [right] {$a$} ();
            \end{tikzpicture}
        \end{basedtikz} 
    \end{itemize}

    \textbf{Punto 2: }Sea $\Sigma=\{a,b\}$
\begin{itemize}[label={$\bullet$}]
    \item Diseñar un AFD que acepte el lenguaje de todas las cadenas que contienen un numero par de $aes$ y un numero par de $bes$.\\

     Recordemos que si por ejemplo queremos construir un autómata que acepte el lenguaje de las cadenas que tienen una cantidad par de $aes$ hacemos la siguiente construcción:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0);
        \end{tikzpicture}
    \end{basedtikz}
Note como la construcción para cantidad par de $bes$ es la misma entonces basta simplemente con agregar un camino para estas en el autómata ya diseñado hacia un nuevo estado:
\begin{basedtikz}
\centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0);
        \end{tikzpicture}
    \end{basedtikz}

Observe que este autómata no acepta por ejemplo las cadenas $abab$ o $abba$. Aquí entra en juego la recomendación de usar 4 estados para la construcción y de esta forma podremos crear estos caminos para aceptar aquellas cadenas que antes no y que si son generadas por el lenguaje:

\begin{basedtikz}
\centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    Algo importante a destacar aquí es que el único estado de aceptación es $q_0$ ya que en los demás siempre hay cantidad impar de $aes$ o $bes$. Esto es relevante ya que es la esencia del siguiente ejercicio.

    \item Para cada combinación de condiciones 'par' e 'impar' y de las conectivas 'o' e 'y', diseñar un AFD que acepte el lenguaje $L$ definido por
    L=\text{lenguaje de las cadenas con un numero par/impar de }aes\text{ y/o un numero par/impar de }bes.

     Observe que para este ejercicio tenemos ocho posibilidades en total, bueno para ser exactos simplemente tenemos que hacer $7$ ya que en el anterior ya cubrimos el caso par de $aes$ y par de $bes$. La forma en que determinaremos que estados se vuelven de aceptación es considerando cadenas básicas que cumplen las condiciones y en que estado terminan.\\

    \textbf{Caso 1: }Impar de $aes$ o impar de $bes$. Note que en el autómata original $q_1,q_2$ y $q_3$ no son de aceptación ya que en todos $aes$ o $bes$ son impares, luego en este caso estos tres se vuelven de aceptación mientras que $q_0$ ya no lo es.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 2: }Par de $aes$ o par de $bes$. Observe que el estado $q_0$ lo mantenemos como aceptación, luego note que la cadena $abb$ es aceptada por la condición y si seguimos este camino en el autómata $q_1$ debe ser de aceptación. De la misma manera $q_2$ tiene que ser de aceptación ya que la cadena $baa$ también es aceptada.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 3: }Impar de $aes$ e impar de $bes$. Note que en la construcción anterior el estado $q_3$ no es de aceptación ya que es el único lugar donde $aes$ y $bes$ son impares, entonces para este caso ese va a ser nuestro único estado de aceptación.
     
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 4: }Par de $aes$ e impar de $bes$. Observe que una cadena aceptada por estas condiciones es la cadena $baa$ y esta es aceptada en $q_2$ luego este tiene que ser de aceptación. Ahora note que ninguno de los demás es de aceptación ya que $q_0,q_1$ aceptan cadenas con un numero par de $bes$ y $q_3$ acepta cadenas con un numero impar de $aes$.
\begin{basedtikz}
\centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 5: }Impar de $aes$ o par de $bes$. Por las $bes$ pares $q_0$ es de aceptación. Por el impar de $aes$, $q_1$ y $q_3$ son de aceptación.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 6: }Impar de $aes$ y par de $bes$. Una cadena que debe ser aceptada es por ejemplo $abb$, luego el estado que la acepta es $q_1$, ademas note que los demás estados no son de aceptación ya que aceptan las cadenas $\lambda,b$ y $ab$ que no cumplen las condiciones.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 7: }Par de $aes$ o Impar de $bes$.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

Observe que por ejemplo la condición del caso $7$ es la negación de la condición del caso $6$. Ademas los estados de aceptación del caso $6$ son de no aceptación en el caso $7$ y viceversa. Esto quedaría mas que nada como una mera curiosidad sino fuera por que posteriormente se mostrara que esta es una forma de construir autómatas para lenguajes que tienen una condición negativa. Primero se construirá el autómata que acepta la condición positiva y luego para aceptar la negación se cambian los estados de aceptación a no aceptación y viceversa.
\end{itemize}


\textbf{Punto 3: }Sea $\Sigma=\{0,1\}.$ Diseñar AFD que acepten los siguientes lenguajes:
\begin{itemize}[label={$\bullet$}]
    \item El lenguaje de todas las cadenas que terminan en 01.\\

     Primero debemos forzar el camino para aceptar $01$ que es la cadena mínima.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    Ahora observe la cadena puede empezar por unos arbitrarios, estos lo generamos por medio de un bucle en el estado inicial. Luego lo mismo pasa en $q_1$ pero con ceros. Por ultimo al estar ya en el estado de aceptación note que si sale un $0$ o un $1$ la cadena dejaría de ser de aceptada y uno estaría tentado a pensar que van a un estado limbo y que el autómata quedaría de la siguiente forma:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
Pero note que las cadenas $0101$ y $101101$ son cadenas validas pero no son aceptadas por el autómata. Esto se arregla fácilmente con añadir los bucles correspondientes desde el ultimo estado.
    \begin{basedtikz}
    \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0)
        (q1) edge [bend left] node [above] {$1$} (q2);
            \end{tikzpicture}
        \end{basedtikz}
        \item El lenguaje de todas las cadenas que tienen un numero par $\geq2$ de unos.\\

         Primero forzamos la mínima cadena par de unos que es $11$, luego realizamos la construcción para obtener cantidad par de unos y añadimos bucles de $0$ en todos los estados ya que estos no tienen restricción alguna.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$1$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item El lenguaje de todas las cadenas con longitud $\geq4.$\\

         Al igual que hacíamos con las expresiones regulares, hacemos primero que se acepten todas las cadenas de longitud $4$ que son las mínimas y posteriormente por medio de un bucle se generaran todas las demás.
          
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2] {$q_4$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$0,1$} (q1)
        (q1) edge node [above] {$0,1$} (q2)
        (q2) edge node [above] {$0,1$} (q3)
        (q3) edge node [above] {$0,1$} (q4)
        (q4) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item El lenguaje de todas las cadenas que contienen por lo menos dos unos consecutivos.\\

         Nuevamente forzaremos el hecho de que hayan al menos dos unos seguidos, en el primer estado agregaremos un bucle de $0$ ya que estos pueden ser arbitrarios y en el ultimo un bucle $0,1$ ya que ahi ya se cumple la condición entonces da igual que salga después
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        Note que agregamos una flecha de $q_1$ a $q_0$ con etiqueta $0$ ya que esto permite aceptar cadenas como $101011001$ que sin este no serian aceptadas.

        \item El lenguaje de todas las cadenas que tienen un numero par de ceros pero no tienen dos ceros consecutivos.\\

         Observe que debemos construir el camino forzando a que halla por lo menos un $1$ entre dos ceros (no olvide que la cadena $\lambda$ es de aceptación en este lenguaje).
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, right of=q2, accepting] {$q_3$};
                \path[thick]
                (q0) edge [loop above] node [above] {$1$} ()
                (q0) edge node [above] {$0$} (q1)
                (q1) edge node [above] {$1$} (q2)
                (q2) edge [loop above] node [above] {$1$} ()
                (q2) edge node [above] {$0$} (q3)
                (q3) edge [bend left] node [below] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        Note que estamos acostumbrados a que cuando hacemos la construcción de pares el bucle se hace con los que queremos forzar a ser pares, pero en este caso se vuelve al estado inicial por medio de un $1$ es debido a que la condición de que no pueden haber $2$ ceros consecutivos.
        \item $(01\cup101)^*$\\

         Note que podemos formar los respectivos bucles por separado ya que la cadena empieza por $01$ o por $101$ y luego estas se concatenan en cualquier  orden pero siempre son esos dos bloques.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, below left of=q0] {$q_1$};
                \node (q2) [state, below right of=q0] {$q_2$};
                \node (q3) [state, above of=q0] {$q_3$};
                \path[thick]
                (q0) edge [bend left] node [left] {$0$} (q3)
                (q3) edge [bend left] node [right] {$1$} (q0)
                (q0) edge node [above] {$1$} (q1)
                (q1) edge node [below] {$0$} (q2)
                (q2) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        \item $1^+(10\cup01^+)^*$\\ 

        Este AFD fue construido por medio de un algoritmo que sera presentado en un capitulo posterior. Siendo sincero me fue imposible construir este AFD por mera inspección de la expresión regular.
        
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q1] {$q_2$};
            \node (q3) [state, below right of=q1, accepting] {$q_3$};
            \node (q4) [state, below right of=q2, accepting] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$}; 
            \path [thick]
            (q0) edge node [above] {$1$} (q1)
            (q1) edge [bend left] node [above] {$0$} (q2)
            (q1) edge [bend right] node [below] {$1$} (q3)
            (q2) edge [bend left] node [above] {$1$} (q4)
            (q4) edge [bend left] node [below] {$0$} (q2)
            (q3) edge [loop below] node [below] {$1$} ()
            (q3) edge [bend right] node [below] {$0$} (q4)
            (q4) edge [bend left] node [above] {$1$} (q5)
            (q5) edge [bend left] node [below] {$0$} (q4)
            (q5) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}
\end{itemize}

\textbf{Punto 4: }Sea $\Sigma=\{a,b,c\}$. Diseñar AFD que acepten los siguientes lenguajes:
\begin{itemize}[label={$\bullet$}]
    \item $a^*b^*c^*$\\

     Basta con forzar los bucles para cada elemento y el hecho de que todas las cadenas tienen la misma secuencia de elementos, $aes$ arbitrarias luego $bes$ arbitrarias y por ultimo $ces$ arbitrarias.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \path[thick]
            (q0) edge [loop above] node [above] {$a$} () 
            (q1) edge [loop above] node [above] {$b$} ()
            (q2) edge [loop above] node [above] {$c$} ()
            (q0) edge node [above] {$b$} (q1) 
            (q1) edge node [above] {$c$} (q2)
            (q0) edge [bend right] node [below] {$c$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    \item $a^+b^*\cup ac^*\cup b^*ca^*$\\

     Haremos una construcción por dos caminos distintos a partir de las cadenas mínimas. La primera es el camino que se forma con la cadena $a$.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ();
        \end{tikzpicture}
    \end{basedtikz}
    Esta construcción se puede ver un tanto enredada pero si nos fijamos detalladamente simplemente se están considerando tres casos, primero las cadenas de la forma $ac^*$, segundo las cadenas de la forma $ab^*$ y por ultimo las $aa^+b^*$ (note que es necesario dividir estos dos últimos caminos así debido a la definición de los AFD).
    Ahora solo nos falta construir el camino para aceptar cadenas de la forma $b^*ca^*$.
     
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \node (q5) [state, below of=q0] {$q_5$};
        \node (q6) [state, right of=q5, accepting] {$q_6$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ()
        (q0) edge node [left] {$b$} (q5)
        (q5) edge [loop below] node [below] {$b$} ()
        (q5) edge node [below] {$c$} (q6)
        (q6) edge [loop below] node [below] {$a$} ()
        (q0) edge node [above] {$c$} (q6);
        \end{tikzpicture}
    \end{basedtikz}
    Note como forzamos la cadena mínima $c$ y usamos un estado extra para generar el bucle de $bes$ ya que si no lo hacemos y colocamos ese bucle en $q_0$ alteraríamos toda la parte superior del autómata. De esta forma ya estamos considerando todas las cadenas que son dadas aceptadas en el lenguaje.
    \item $a^*(ba\cup ca)^+$\\

     Observe que las cadenas mínimas son $ba$ y $ca$ luego basta con forzarlas y notar que ademas de las $aes$ arbitrarias iniciales siempre luego de una $b$ o $c$ va una $a$ y viceversa.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$}; 
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$b,c$} (q1)
        (q1) edge [bend left] node [above] {$a$} (q2)
        (q2) edge [bend left] node [below] {$b,c$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

\textbf{Punto 5: }Sea $L=\{a^{2i}b^{3j}:i,j\geq0\}$ definido sobre el alfabeto $\Sigma=\{a,b\}.$ Encontrar una expresión regular para $L$ y un AFD $M$ tal que $L(M)=L.$\\

 Primero es bastante evidente por la definición que se nos da que la expresión regular que determina a $L$ es:
$$(aa)^*(bbb)^*=\left(a^2\right)^*\left(b^3\right)^*$$
Ahora para la construcción del AFD $M$ tal que $L(M)=L$, basta con primero realizar la construcción para obtener una cantidad par de $aes$ y posteriormente agregamos un camino para aceptar cantidad de $bes$ que sean múltiplos de $3$ (esta construcción es muy parecida a la de pares solo que en vez de concatenar bloques $bb$ estamos concatenando bloques $bbb$).
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \node (q4) [state, right of=q3, accepting] {$q_4$};
            \path [thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge node [left] {$b$} (q2)
            (q2) edge node [above] {$b$} (q3)
            (q3) edge node [above] {$b$} (q4)
            (q4) edge [bend left=45] node [below] {$b$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    Uno podría pensar que para hacer que se aceptaran esos bloques de $bbb$ sobra ese estado final y se puede ahorrar haciendo que vaya una flecha de $q_3$ a $q_0$ con la etiqueta $b$, pero note que eso causaría que las cadenas de la forma $(bbb)^*(aa)^*$ fueran aceptadas lo cual no es contemplado dentro del lenguaje.
    
    $\hfill \blacklozenge$

    \section{Autómatas finitos no-deterministas (AFN)} 

  A continuación construiremos AFN los cuales no tienen las mismas restricciones que los AFD y por tanto son bastante mas sencillos de construir, eso si algo de vital importancia es que al igual que en los AFD debemos tener cuidado de no construir caminos que acepten cadenas que no son contempladas por el lenguaje.\\

  \textbf{Punto 1: }Sea $\Sigma=\{a,b\}.$ Diseñar AFN que acepten los siguientes lenguajes:

  \begin{itemize}[label={$\bullet$}]

        \item $a(a\cup ab)^*$\\

         Tenemos que asegurar que toda cadena empiece por una $a$, luego simplemente generamos los dos bucles necesarios uno para $aes$ arbitrarias y el otro para bloques $ab$.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0, accepting] {$q_1$};
               \node (q2) [state, right of=q1] {$q_2$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge [bend left] node [above] {$a$} (q2)
               (q2) edge [bend left] node [below] {$b$} (q1);
            \end{tikzpicture}
        \end{basedtikz}
        Observe que este es un AFN ya que hay dos flechas con etiqueta $a$ saliendo desde $q_1$.
        \item $a^+b^*a$\\

         Para la construcción forzamos la cadena mínima $aa$ junto a el bucle de $aes$ inicial.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0] {$q_1$};
               \node (q2) [state, right of=q1, accepting] {$q_2$};
               \node (q3) [state, below of=q1] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge node [above] {$a$} (q2)
               (q1) edge node [left] {$b$} (q3)
               (q3) edge [loop below] node [below] {$b$} ()
               (q3) edge [bend right] node [below] {$a$} (q2);  
            \end{tikzpicture}
        \end{basedtikz}
        Note que las $bes$ intermedias las agregamos por medio de un estado extra generando un camino nuevo.
        \item $a^*b\cup b^*a$\\

         Basta con construir un camino para las cadenas mínimas $a$ y $b$, luego construimos dos caminos extra para aceptar $a^*b$ y $b^*a$ respectivamente.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a,b$} (q3)
               (q0) edge [bend left] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q0) edge [bend right] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q1) edge [loop above] node [above] {$a$} ()
               (q2) edge [loop below] node [below] {$b$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item $b^*(ab\cup ba)^*$\\

         Forzaremos las $bes$ arbitrarias en el primer estado y luego generamos los caminos correspondientes para la concatenación de $ab$ y $ba$.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2);
            \end{tikzpicture}
        \end{basedtikz}
        \item $b^*(ab\cup ba)^*a^*$\\

         Observe que el lenguaje es exactamente igual al anterior a excepción de que ahora las cadenas pueden terminar en un numero arbitrario de $aes$, pero como estamos construyendo un AFN basta con notar que agregando un nuevo estado que sea de aceptación con un bucle de $aes$ es suficiente.
        \begin{basedtikz}
        \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \node (q4) [state, right of=q3, accepting] {$q_4$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2)
               (q3) edge node [above] {$a$} (q4)
               (q4) edge [loop above] node [above] {$a$} ();
            \end{tikzpicture}
        \end{basedtikz}
    \end{itemize}

    \textbf{Punto 2: }Sea $\Sigma=\{0,1\}.$ Diseñar AFN que acepten los siguientes lenguajes:  

    \begin{itemize}[label={$\bullet$}]
        \item $(01\cup001)^*$\\

         Simplemente construimos los caminos para aceptar $01$ y $001$ por separado.
          
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$1$} (q0)
            (q0) edge node [left] {$0$} (q2)
            (q2) edge node [below] {$0$} (q3)
            (q3) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        \item $(01^*0\cup10^*)^*$\\

         Nuevamente basta con construir los caminos correspondientes a $01^*0$ y $10^*$.
        
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$0$} (q0)
            (q0) edge [bend right] node [left] {$1$} (q2)
            (q2) edge [bend right] node [right] {$0$} (q0)
            (q2) edge [loop below] node [below] {$0$} ()
            (q0) edge [loop above] node [above] {$1$} ()
            (q1) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}

        Observe que es necesario incluir ese bucle con etiqueta $1$ para aceptar cuando solo hay unos en la expresión $10^*$ (es decir en el caso donde $1$ se concatena con $\lambda$). 

        \item $1^*01\cup10^*1$\\

         Construimos los caminos de las cadenas $10^*1$ y $01$.
          
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \node (q3) [state, above of=q1] {$q_3$};
            \node (q4) [state, below of=q0] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$0$} (q1)
            (q1) edge node [above] {$1$} (q2)
            (q0) edge [bend left] node [above] {$1$} (q3)
            (q3) edge [bend left] node [above] {$1$} (q2)
            (q3) edge [loop above] node [above] {$0$} ()
            (q0) edge node [left] {$1$} (q4)
            (q4) edge node [below] {$0$} (q1)
            (q4) edge [loop below] node [below] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        Note que usamos un estado adicional para construir el camino para aceptar $1^*01$.
    \end{itemize}

    $\hfill \blacklozenge$

    \section{Equivalencia computacional entre los AFD y los AFN}

    En la anterior sección se hizo bastante notorio como la construcción de AFN es mucho mas sencilla que la de un AFD. En esta sección se nos enseña que por medio de un proceso podemos convertir cualquier AFN en un AFD, algo que resulta extremadamente conveniente pero aveces el proceso es algo tedioso.\\ 

    \textbf{Punto 1: }Utilizando el procedimiento de conversión presentado en esta sección, encontrar AFD equivalentes a los siguientes AFN:\\ 
    A continuación en cada AFD que construyamos omitiremos los estados inútiles.\\

    \begin{itemize}[label={$\bullet$}]
        \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$b$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q0)
            (q0) edge node [left] {$b$} (q2)
            (q2) edge node [below] {$a$} (q3)
            (q3) edge node [left] {$b$} (q0);
            \end{tikzpicture}
            \end{center}   
        Primero realicemos la extensión de la tabla.
       
       \begin{center}
               \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_1,q_2\}$ \\ 
        \hline
        $q_1$ &$\{q_0\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\varnothing$ \\ 
        \hline
        $q_3$&$\varnothing$&$\{q_0\}$\\ 
        \hline\hline
        
        $\{q_1,q_2\}$&$\{q_0,q_3\}$&$\varnothing$\\ 
        \hline
        $\{q_0,q_3\}$&$\varnothing$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_3\}$&$\{q_1,q_2\}$\\ 
        \hline
        \end{tabular}
       \end{center}
       
        En el AFN original teníamos que los estados de aceptación eran $q_0$ y $q_3$ luego en el AFD los estados de aceptación son todos aquellos que contengan alguno de estos dos. Por  estética definiremos $q_4:=\{q_1,q_2\},q_5:=\{q_0,q_3\}$ y $q_6:=\{q_0,q_1,q_2\}$. 
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q4) [state, right of=q0] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$};
            \node (q6) [state, right of=q5, accepting] {$q_6$};
            \path[thick]
            (q0) edge node [above] {$b$} (q4)
            (q4) edge node [above] {$a$} (q5)
            (q5) edge [bend left] node [above] {$b$} (q6)
            (q6) edge [bend left] node [below] {$a$} (q5)
            (q6) edge [bend left=60] node [below] {$b$} (q4);
            \end{tikzpicture}
        \end{basedtikz}

        \item \hfill
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$b$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q0)
            (q0) edge node [left] {$b$} (q2)
            (q1) edge [loop above] node [above] {$a$} ()
            (q2) edge node [below] {$a$} (q3)
            (q3) edge node [left] {$b$} (q0);
            \end{tikzpicture}    
         \end{center} 

         Realicemos la extensión de la tabla.

        \begin{center}
            \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_1,q_2\}$ \\ 
        \hline
        $q_1$ &$\{q_0,q_1\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\varnothing$ \\ 
        \hline
        $q_3$&$\varnothing$&$\{q_0\}$\\ 
        \hline
        \hline
        $\{q_1,q_2\}$&$\{q_0,q_1,q_3\}$&$\varnothing$\\ 
        \hline
        $\{q_0,q_1\}$&$\{q_0,q_1\}$&$\{q_1,q_2\}$\\ 
        \hline
        $\{q_0,q_1,q_3\}$&$\{q_0,q_1\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_1,q_3\}$&$\{q_1,q_2\}$\\ 
        \hline       
        \end{tabular}   
        \end{center}
        Nuevamente los estados de aceptación del AFD son todos aquellos que contienen $q_0$ o $q_3$. Ahora definimos $q_4:=\{q_1,q_2\},q_5:=\{q_0,q_1,q_3\},q_6:=\{q_0,q_1\}$ y $q_7:=\{q_0,q_1,q_2\}$.

        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q4) [state, right of=q0] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$};
            \node (q6) [state, right of=q5, accepting] {$q_6$};
            \node (q7) [state, below of=q5, accepting] {$q_7$};
            \path[thick]
            (q0) edge node [above] {$b$} (q4)
            (q4) edge node [above] {$a$} (q5)
            (q5) edge node [above] {$a$} (q6)
            (q6) edge [bend right=45] node [above] {$b$} (q4)
            (q6) edge [loop below] node [below] {$a$} ()
            (q5) edge [bend right] node [left] {$b$} (q7)
            (q7) edge [bend right] node [right] {$a$} (q5)
            (q7) edge [bend left] node [below] {$b$} (q4);
            \end{tikzpicture}
        \end{basedtikz}

        \item \hfill 
        \begin{center}
          \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};;
            \path[thick]
            (q0) edge [loop above] node [above] {$b$} ()
            (q1) edge [loop above] node [above] {$a$} ()
            (q0) edge node [above] {$b$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q2)
            (q2) edge [bend left] node [below] {$b$} (q1);
            \end{tikzpicture}   
        \end{center}
        Realicemos la extensión de la tabla.
        \begin{center}
             \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_0,q_1\}$\\ 
        \hline
        $q_1$ &$\{q_1,q_2\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\varnothing$& $\{q_1\}$ \\  
        \hline
        \hline
        $\{q_0,q_1\}$&$\{q_1,q_2\}$&$\{q_0,q_1\}$\\
        \hline
        $\{q_1,q_2\}$&$\{q_1,q_2\}$&$\{q_1\}$\\ 
        \hline             
        \end{tabular}   
        \end{center}
        Los estados de aceptación serán aquellos que contengan $q_1$ y $q_2$, ademas definimos $q_3:=\{q_0,q_1\}$ y $q_4:=\{q_1,q_2\}$.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q3) [state, right of=q0, accepting] {$q_3$};
            \node (q4) [state, right of=q3, accepting] {$q_4$};
            \node (q1) [state, right of=q4, accepting] {$q_1$};
            \path[thick]
            (q0) edge node [above] {$b$} (q3)
            (q3) edge node [above] {$a$} (q4)
            (q3) edge [loop above] node [above] {$b$} ()
            (q4) edge [loop above] node [above] {$a$} ()
            (q4) edge [bend left] node [above] {$b$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q4);
            \end{tikzpicture}
        \end{basedtikz}
         
        \item \hfill
        \begin{center}
          \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};;
            \path[thick]
            (q0) edge [loop above] node [above] {$a$} ()
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q1) 
            (q2) edge [bend left=60] node [below] {$a$} (q0);
            \end{tikzpicture}  
        \end{center}
        Creo que ya es evidente que es lo primero que haremos.
      \begin{center}
          \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\{q_0,q_1\}$ & $\varnothing$\\ 
        \hline
        $q_1$ &$\varnothing$ &$\{q_2\}$ \\ 
        \hline
        $q_2$& $\{q_0,q_1\}$& $\varnothing$ \\  
        \hline
        \hline
        $\{q_0,q_1\}$&$\{q_0,q_1\}$&$\{q_2\}$\\
        \hline           
        \end{tabular}   
      \end{center}
        Los estados de aceptación son aquellos que contienen $q_0$ y $q_2$, ademas definimos $q_3:=\{q_0,q_1\}$.
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q3) [state, right of=q0, accepting] {$q_3$};
            \node (q2) [state, right of=q3, accepting] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q3)
            (q3) edge [loop above] node [above] {$a$} ()
            (q3) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q3);
            \end{tikzpicture}
        \end{basedtikz}
    \end{itemize}

    \textbf{Punto 2: }Sean $\Sigma=\{0,1\}$ y $L_3$ el lenguaje de todas las cadenas de longitud $\geq3$ en las que el tercer símbolo, de derecha a izquierda es un 1. Diseñar un AFN con cuatro estados que acepte a $L_3$ y aplicar luego el procedimiento de conversión para encontrar un AFD equivalente.\\

Note primero como ayuda que la expresión regular que describe $L_3$ es:
$$(0\cup1)^*1(0\cup1)^2$$
 Luego el AFN que describe este lenguaje surge de una construcción bastante natural solo observando la expresión regular.
 
 \begin{basedtikz}
 \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
    \node (q0) [state, initial] {$q_0$};
    \node (q1) [state, right of=q0] {$q_1$};
    \node (q2) [state, right of=q1] {$q_2$};
    \node (q3) [state, right of=q2, accepting] {$q_3$};
    \path[thick]
    (q0) edge [loop above] node [above] {$0,1$} ()
    (q0) edge node [above] {$1$} (q1)
    (q1) edge node [above] {$0,1$} (q2)
    (q2) edge node [above] {$0,1$} (q3);
    \end{tikzpicture}
\end{basedtikz}

Ahora realicemos la extensión de la tabla.

\begin{center}
          \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $0$ & $1$\\
        \hline 
        $q_0$ & $\{q_0\}$ & $\{q_0,q_1\}$\\ 
        \hline
        $q_1$ &$\{q_2\}$ &$\{q_2\}$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\{q_3\}$ \\  
        \hline
        $q_3$& $\varnothing$& $\varnothing$ \\
        \hline
        \hline 
        $\{q_0,q_1\}$&$\{q_0,q_2\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_2\}$&$\{q_0,q_3\}$&$\{q_0,q_1,q_3\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_2,q_3\}$&$\{q_0,q_1,q_2,q_3\}$\\
        \hline
        $\{q_0,q_3\}$&$\{q_0\}$&$\{q_0,q_1\}$\\
        \hline
        $\{q_0,q_1,q_3\}$&$\{q_0,q_2\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_2,q_3\}$&$\{q_0,q_3\}$&$\{q_0,q_1,q_3\}$\\
        \hline
        $\{q_0,q_1,q_2,q_3\}$&$\{q_0,q_2,q_3\}$&$\{q_0,q_1,q_2,q_3\}$\\
        \hline
        \end{tabular}
      \end{center}
Ahora observe que en el AFD los estados de aceptación serán aquellos que contengan a $q_3$, ademas definimos $q_4:=\{q_0,q_1\},q_5:=\{q_0,q_2\},q_6:=\{q_0,q_1,q_2\},q_7:=\{q_0,q_3\},q_8:=\{q_0,q_1,q_3\},q_9:=\{q_0,q_2,q_3\}$ y $q_{10}:=\{q_0,q_1,q_2,q_3\}$.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
    \node (q0) [state, initial] {$q_0$};
    \node (q4) [state, right of=q0] {$q_4$};
    \node (q5) [state, right of=q4] {$q_5$};
    \node (q7) [state, right of=q5, accepting] {$q_7$};
    \node (q6) [state, below of=q4] {$q_6$};
    \node (q8) [state, right of=q6, accepting] {$q_8$};
    \node (q9) [state, right of=q8, accepting] {$q_9$};
    \node (q10) [state, below of=q8, accepting] {$q_{10}$};
    \path[thick]
    (q0) edge [loop below] node [below] {$0$} ()
    (q0) edge node [above] {$1$} (q4)
    (q4) edge node [above] {$0$} (q5)
    (q4) edge node [left] {$1$} (q6)
    (q5) edge node [above] {$0$} (q7)
    (q5) edge [bend left] node [right] {$1$} (q8)
    (q7) edge [bend right=60] node [above] {$0$} (q0)
    (q7) edge [bend right=45] node [above] {$1$} (q4)
    (q6) edge [bend right=45] node [below] {$0$} (q9)
    (q6) edge [bend right] node [below] {$1$} (q10)
    (q8) edge [bend left] node [left] {$0$} (q5)
    (q8) edge node [above] {$1$} (q6)
    (q9) edge node [right] {$0$} (q7)
    (q9) edge node [above] {$1$} (q8)
    (q10) edge [bend right] node [below] {$0$} (q9)
    (q10) edge [loop below] node [below] {$1$} ();
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 3: }Sea $M=\{\Sigma,Q,q_0,F,\delta\}$ un AFD. Demostrar por recursión sobre cadenas que la extensión $\delta$ satisface
$$\delta(q_0,uv)=\delta(\delta(q,u),v),$$
para todo estado $q\in Q$, y todas las cadenas $u,v\in\Sigma^*.$
\begin{proof}
Dados $q\in Q$ y $u,v\in\Sigma^*$ realizaremos recursión sobre la cadena $v$.\\
Si $v=\lambda$ es evidente por la definición de la extensión de $\delta$ que:
$$\delta(\delta(q,u),\lambda)=\delta(q,u)=\delta(q,u\lambda)$$
Como tenemos el caso base consideremos que nuestra hipótesis recursiva se cumple es decir:
$$\delta(q,uv)=\delta(\delta(q,u),v)$$ 
Ahora veamos que ocurre con $va$ donde $a\in\Sigma$
\begin{align*}
      \delta(q,uva)&=\delta(\delta(q,uv),a)&(\text{Definición de la extensión de }\delta)\\
      &=\delta(\delta(\delta(q,u),v),a)&(\text{Hipótesis recursiva})\\
      &=\delta(\delta(q,u),va)&(\text{Definición de la extensión de }\delta)
  \end{align*} 
De esta manera concluimos que la propiedad se cumple. 

\end{proof}
\textbf{Punto 4: }Sea $M=\{\Sigma,Q,q_0,F,\Delta\}$ un AFN. Demostrar por recursión sobre cadenas que la extensión $\Delta$ satisface
$$\Delta(q_0,uv)=\Delta(\Delta(q,u),v),$$
para todo estado $q\in Q$, y todas las cadenas $u,v\in\Sigma^*.$ 
\begin{proof}
Dados $q\in Q$ y $u,v\in\Sigma^*$ procederemos igual que en el punto anterior.\\
Si $v=\lambda$ por la definición de la extensión de $\Delta$ se tiene que:
$$\Delta(\Delta(q,u),\lambda)=\bigcup_{p\in\Delta(q,u)}\Delta(p,\lambda)=\bigcup_{p\in\Delta(q,u)}\{p\}=\Delta(q,u)=\Delta(q,u\lambda)$$ 
Como tenemos el caso base consideremos que nuestra hipótesis recursiva se cumple es decir:
$$\Delta(q,uv)=\Delta(\Delta(q,u),v)$$ 
Ahora veamos que ocurre con $va$ donde $a\in\Sigma$ 
\begin{align*}
    \Delta(q,uva)&=\Delta(\Delta(q,uv),a)&(\text{Definición de la extensión de }\Delta)\\
      &=\Delta(\Delta(\Delta(q,u),v),a)&(\text{Hipótesis recursiva})\\
      &=\Delta(\Delta(q,u),va)&(\text{Definición de la extensión de }\Delta)  
  \end{align*} 
De esta manera concluimos que la propiedad se cumple. 
 
\end{proof}

$\hfill \blacklozenge$

\section{Autómatas con transiciones \texorpdfstring{\boldmath$\lambda$}{lambda} (AFN-\texorpdfstring{\boldmath$\lambda$}{lambda})} 

Si bien previamente habíamos observado como los AFN eran bastante fáciles de construir, en esta sección nos daremos cuenta de que existe incluso construcciones aun mas sencillas, que son los AFN-$\lambda$. En esta sección veremos como construirlos y luego observaremos su relevancia.\\

\textbf{Punto 1: }Sea $\Sigma=\{a,b\}.$ Diseñar AFN-$\lambda$ que acepten los siguientes lenguajes:

\begin{itemize}[label={$\bullet$}]
    \item $(ab\cup b)^*ab^*a^*.$\\
     
     Para este autómata realizaremos una construcción en serie, concatenando los autómatas respectivos de cada parte del lenguaje, note que $a$ es la mínima cadena de aceptación.
    \begin{basedtikz}
    \centering
       \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
       \node (q0) [state, initial] {$q_0$};
       \node (q1) [state, below of=q0] {$q_1$};
       \node (q2) [state, right of=q0] {$q_2$};
       \node (q3) [state, right of=q2] {$q_3$};
       \node (q4) [state, right of=q3, accepting] {$q_4$};
       \path[thick]
       (q0) edge [loop above] node [above] {$b$} ()
       (q0) edge [bend right] node [left] {$a$} (q1)
       (q1) edge [bend right] node [right] {$b$} (q0)
       (q0) edge node [above] {$\lambda$} (q2)
       (q2) edge node [above] {$a$} (q3)
       (q3) edge [loop above] node [above] {$b$} ()
       (q3) edge node [above] {$\lambda$} (q4)
       (q4) edge [loop above] node [above] {$a$} ();
       \end{tikzpicture} 
    \end{basedtikz}

    \item $ab^*\cup ba^*\cup b(ab\cup ba)^*.$\\
     
     Basta con realizar una construcción en paralelo para cada expresión de la unión. Es decir construimos un AFD para $ab^*,ba^*$ y $b(ab\cup ba)^*$ respectivamente y luego realizamos la construcción en paralelo.
    \begin{basedtikz}
    \centering
       \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
       \node (q0) [state, initial] {$q_0$};
       \node (q1) [state, right of=q0] {$q_1$};
       \node (q2) [state, right of=q1, accepting] {$q_2$};
       \node (q3) [state, above of=q1] {$q_3$};
       \node (q4) [state, right of=q3, accepting] {$q_4$};
       \node (q5) [state, below of=q1] {$q_5$};
       \node (q6) [state, right of=q5, accepting] {$q_6$};
       \node (q7) [state, right of=q6] {$q_7$};
       \node (q8) [state, below of=q6] {$q_6$};
       \path[thick]
       (q0) edge node [above] {$\lambda$} (q1)
       (q0) edge node [above] {$\lambda$} (q3)
       (q0) edge node [below] {$\lambda$} (q5)
       (q1) edge node [above] {$b$} (q2)
       (q2) edge [loop right] node [right] {$a$} ()
       (q3) edge node [above] {$a$} (q4)
       (q4) edge [loop right] node [right] {$b$} ()
       (q5) edge node [above] {$b$} (q6)
       (q6) edge [bend left] node [above] {$a$} (q7)
       (q7) edge [bend left] node [below] {$b$} (q6)
       (q6) edge [bend right] node [left] {$b$} (q8)
       (q8) edge [bend right] node [right] {$a$} (q6);
       \end{tikzpicture} 
    \end{basedtikz}

    \item $(a\cup aba)^*b^*(ab\cup ba)^*a^*.$ \\

    Nuevamente realizaremos una construcción en serie, note que la cadena $\lambda$ es la mínima que se acepta.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, below of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q0] {$q_3$};
         \node (q4) [state, right of=q3] {$q_4$};
         \node (q5) [state, above of=q4] {$q_5$};
         \node (q6) [state, below of=q4] {$q_6$};
         \node (q7) [state, right of=q4, accepting] {$q_7$};
         \path[thick]
         (q0) edge [loop above] node [above] {$a$} ()
         (q0) edge node [left] {$a$} (q1)
         (q1) edge node [below] {$b$} (q2)
         (q2) edge node [above] {$a$} (q0)
         (q0) edge node [above] {$\lambda$} (q3)
         (q3) edge [loop above] node [above] {$b$} ()
         (q3) edge node [above] {$\lambda$} (q4)
         (q4) edge [bend left] node [left] {$a$} (q5)
         (q5) edge [bend left] node [right] {$b$} (q4)
         (q4) edge [bend left] node [right] {$b$} (q6)
         (q6) edge [bend left] node [left] {$a$} (q4)
         (q4) edge node [above] {$\lambda$} (q7)
         (q7) edge [loop above] node [above] {$a$} ();
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

\textbf{Punto 2: }Sea $\Sigma=\{0,1\}.$ Diseñar AFN-$\lambda$ que acepten los siguientes lenguajes:

\begin{itemize}[label={$\bullet$}]
    \item $(1\cup01\cup001)^*0^*1^*0^+.$\\

    El único autómata que puede resultar un poco complicado de construir es el de la expresión inicial $(1\cup01\cup001)^*$ pero basta con 3 estados, luego simplemente es realizar una construcción en serie.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, below of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q0] {$q_3$};  
         \node (q4) [state, right of=q3] {$q_4$}; 
         \node (q5) [state, right of=q4, accepting] {$q_5$};
         \path[thick]
         (q0) edge [loop above] node [above] {$1$} ()
         (q0) edge [bend right] node [left] {$0$} (q1)
         (q1) edge [bend right] node [right] {$1$} (q0)
         (q1) edge node [below] {$0$} (q2)
         (q2) edge node [above] {$1$} (q0)
         (q0) edge node [above] {$\lambda$} (q3)
         (q3) edge [loop above] node [above] {$0$} ()
         (q3) edge node [above] {$\lambda$} (q4)
         (q4) edge [loop above] node [above] {$1$} ()
         (q4) edge node [above] {$0$} (q5)
         (q5) edge [loop above] node [above] {$0$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item $0^+1(010)^*(01\cup10)^*1^+.$\\

    Nuevamente una construcción en serie basta.
     
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, right of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, below of=q2] {$q_3$};  
         \node (q4) [state, left of=q3] {$q_4$}; 
         \node (q5) [state, right of=q2] {$q_5$};
         \node (q6) [state, above of=q5] {$q_6$};
         \node (q7) [state, below of=q5] {$q_7$};
         \node (q8) [state, right of=q5, accepting] {$q_8$};
         \path[thick]
         (q0) edge node [above] {$0$} (q1)
         (q1) edge [loop above] node [above] {$0$} ()
         (q1) edge node [above] {$1$} (q2)
         (q2) edge node [right] {$0$} (q3)
         (q3) edge node [below] {$1$} (q4)
         (q4) edge node [above] {$0$} (q2)
         (q2) edge node [above] {$\lambda$} (q5)
         (q5) edge [bend left] node [left] {$0$} (q6)
         (q6) edge [bend left] node [right] {$1$} (q5)
         (q5) edge [bend left] node [right] {$1$} (q7)
         (q7) edge [bend left] node [left] {$0$} (q5)
         (q5) edge node [above] {$1$} (q8)
         (q8) edge [loop above] node [above] {$1$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item $(101)^*\cup1^*(1\cup10)^*0^+(01\cup10)^*.$\\

    Observe que en este caso usaremos tanto la construcción en paralelo como la construcción en serie ya que uno de los caminos es relativamente complicado de construir pero con esta construcción es mucho mas sencillo.
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, above right of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q2, accepting] {$q_3$};
         \node (q4) [state, below right of=q0] {$q_4$};
         \node (q5) [state, right of=q4] {$q_5$};
         \node (q6) [state, below of=q5] {$q_6$};
         \node (q7) [state, right of=q5] {$q_7$};
         \node (q8) [state, right of=q7, accepting] {$q_8$};
         \node (q9) [state, above of=q8] {$q_9$};
         \node (q10) [state, below of=q8] {$q_{10}$};
         \path[thick]
         (q0) edge [bend left] node [above] {$\lambda$} (q1)
         (q1) edge node [above] {$1$} (q2)
         (q2) edge node [above] {$0$} (q3)
         (q3) edge [bend right=45] node [above] {$1$} (q1)
         (q0) edge [bend right] node [below] {$\lambda$} (q4)
         (q4) edge [loop above] node [above] {$1$} ()
         (q4) edge node [above] {$\lambda$} (q5)
         (q5) edge [loop above] node [above] {$1$} ()
         (q5) edge [bend right] node [left] {$1$} (q6)
         (q6) edge [bend right] node [right] {$0$} (q5)
         (q5) edge node [above] {$0$} (q7)
         (q7) edge [loop above] node [above] {$0$} ()
         (q7) edge node [above] {$\lambda$} (q8)
         (q8) edge [bend left] node [left] {$0$} (q9)
         (q9) edge [bend left] node [right] {$1$} (q8)
         (q8) edge [bend left] node [right] {$1$} (q10)
         (q10) edge [bend left] node [left] {$0$} (q8);
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

$\hfill \blacklozenge$

\section{Equivalencia computacional entre los AFN-\texorpdfstring{\boldmath$\lambda$}{lambda} y los AFN}

Previamente habíamos observado como si construíamos un AFN para aceptar un lenguaje regular, podíamos por medio de un algoritmo convertirlo en un AFD. En esta sección observaremos como podemos convertir un AFN-$\lambda$ en un AFN.\\

\textbf{Punto 1: }\hfill
\begin{center}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$\lambda$} (q1)
        (q1) edge [loop above] node [above] {$b$} ()
        (q1) edge node [above] {$\lambda$} (q2)
        (q2) edge [loop above] node [above] {$a$} ();
    \end{tikzpicture}
\end{center}
Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1,q_2\}\\
    \lambda[q_1]&=\{q_1,q_2\}\\
    \lambda[q_2]&=\{q_2\}
\end{align*}
Observe que en el autómata original el único estado de aceptación es $q_2$, luego como esta pertenece a $\lambda[q_0],\lambda[q_1]$ y $\lambda[q_2]$, $q_0,q_1$ y $q_2$ son de aceptación en el AFN.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a$} ();
    \end{tikzpicture}
\end{basedtikz}
Antes de hacer la inspección para hallar el AFN, es importante tener en cuenta que las flechas ya existentes con etiquetas distintas a $\lambda$ se mantienen. Como ejemplo de inspección observe que desde $q_0$, por medio de las etiquetas $a$ y $b$ se puede llegar tanto a $q_1$ como a $q_2$ haciendo las concatenaciones $a\lambda,a\lambda\lambda,\lambda b,\lambda b\lambda$ respectivamente. El AFN obtenido es el siguiente:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$a,b$} (q1)
        (q1) edge node [above] {$a,b$} (q2)
        (q0) edge [bend right=45] node [below] {$a,b$} (q2);
    \end{tikzpicture}
\end{basedtikz}
 
\textbf{Punto 2: }\hfill
\begin{center}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, below right of=q0] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$a$} (q1)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [loop above] node [above] {$b$} ()
        (q1) edge node [above] {$\lambda$} (q2)
        (q0) edge node [below] {$\lambda$} (q3)
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [bend left] node [below] {$a$} (q3);
    \end{tikzpicture}
\end{center}

Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_3\}\\
    \lambda[q_1]&=\{q_1,q_2\}\\
    \lambda[q_2]&=\{q_2\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_4\}
\end{align*}
$q_2$ y $q_4$ son de aceptación en el original, por tanto observando las $\lambda$-clausuras, $q_1,q_2$ y $q_4$ son de aceptación en el nuevo autómata. Realizando el proceso de inspección el AFN obtenido es el siguiente:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, below right of=q0] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [loop above] node [above] {$b$} ()
        (q1) edge node [above] {$a,b$} (q2)
        (q0) edge node [below] {$a$} (q2)
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [bend left] node [below] {$a$} (q3)
        (q0) edge [bend left] node [above] {$b$} (q4);
    \end{tikzpicture}
\end{basedtikz}
Si bien la presentación del autómata podría ser mas pulida recomendamos dejar los estados en las posiciones originales para hacer mas evidente y sencillo el proceso de inspección.
 

\textbf{Punto 3: }\hfill
\begin{center}
   \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state, right of=q0, accepting] {$q_2$};
        \node (q1) [state, above of=q2, accepting] {$q_1$};
        \node (q3) [state, above right of=q2] {$q_3$};
        \node (q4) [state, below right of=q2] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$\lambda$} (q1)
        (q0) edge node [above] {$\lambda$} (q2)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [bend left=20] node [left] {$a$} (q3)
        (q3) edge [bend left=20] node [right] {$b$} (q2)
        (q2) edge [bend right=20] node [left] {$b$} (q4)
        (q4) edge [bend right=20] node [right] {$a$} (q2);
    \end{tikzpicture} 
\end{center}
Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1,q_2\}\\
    \lambda[q_1]&=\{q_1\}\\
    \lambda[q_2]&=\{q_2\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_4\}
\end{align*}
Los estados $q_1$ y $q_2$ son de aceptación en el original, en el nuevo autómata también son de aceptación y ademas lo sera el estado $q_0$. Realizando la inspección obtenemos el siguiente AFN:  
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q2) [state, right of=q0, accepting] {$q_2$};
        \node (q1) [state, above of=q2, accepting] {$q_1$};
        \node (q3) [state, above right of=q2] {$q_3$};
        \node (q4) [state, below right of=q2] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$a$} (q1)
        (q0) edge [bend left=10] node [above] {$a$} (q3)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [bend left=20] node [left] {$a$} (q3)
        (q3) edge [bend left=20] node [right] {$b$} (q2)
        (q2) edge [bend right=20] node [left] {$b$} (q4)
        (q4) edge [bend right=20] node [right] {$a$} (q2)
        (q0) edge [bend right] node [below] {$b$} (q4);
    \end{tikzpicture}
\end{basedtikz} 
 
\textbf{Punto 4: }\hfill
\begin{center}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, above of=q0] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [left] {$a$} (q4)
        (q4) edge [bend left] node [right] {$b$} (q0)
        (q0) edge node [above] {$\lambda$} (q1)
        (q1) edge node [above] {$a$} (q2)
        (q2) edge node [above] {$\lambda$} (q3)
        (q2) edge [loop above] node [above] {$b$} ()
        (q3) edge [loop above] node [above] {$a$} ()
        (q4) edge node [above] {$\lambda$} (q1);
    \end{tikzpicture}
\end{center}

Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1\}\\
    \lambda[q_1]&=\{q_1\}\\
    \lambda[q_2]&=\{q_2,q_3\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_1,q_4\}
\end{align*}
El único estado de aceptación original es $q_3$ y la única $\lambda$-clausura a la que pertenece es $\lambda[q_2]$ entonces en el nuevo autómata los estados de aceptación son $q_2$ y $q_3$. Realizando el proceso de inspección obtenemos el siguiente AFN:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, above of=q0] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [left] {$a$} (q4)
        (q4) edge [bend left] node [right] {$b$} (q0)
        (q0) edge node [above] {$a$} (q1)
        (q1) edge node [above] {$a$} (q2)
        (q2) edge node [above] {$a,b$} (q3)
        (q2) edge [loop above] node [above] {$b$} ()
        (q3) edge [loop above] node [above] {$a$} ()
        (q4) edge node [above] {$b$} (q1)
        (q4) edge [bend left] node [above] {$a$} (q2)
        (q4) edge [bend left] node [above] {$a$} (q3)
        (q0) edge [bend right] node [below] {$a$} (q2)
        (q0) edge [bend right=45] node [below] {$a$} (q3);
    \end{tikzpicture}
\end{basedtikz}
Observe que la importancia radica en el hecho de que de ahora en adelante si nos atascamos en la construcción de un AFD e incluso de un AFN podemos siempre construir un AFN-$\lambda$, luego convertirlo en un AFN y por ultimo convertirlo en un AFD. Si bien es un proceso largo nos garantiza un AFD que funcione.\\
Por ultimo en esta sección todas las conversiones fueron hechas por inspección, pero se pueden hacer por medio de la formula brindada en las notas. Sugerimos que revisen que las construcciones hechas son correctas por medio de la formula y como ejercicio interesante conviertan los AFN de esta sección en AFD.

$\hfill \blacklozenge$

\section{Complemento de un autómata determinista}

Previamente habíamos mencionado que a partir de un AFD con una condición podíamos construir un AFD para la negación de esa condición cambiando los estados de aceptación. En esta sección eso sera lo que haremos.\\ 

\textbf{Punto 1: }El lenguaje de todas las cadenas que no contienen la subcadena $bc.$ Alfabeto: $\{a,b,c\}$. \\

Construyamos primero un AFD tal que acepte todas las cadenas que contienen la subcadena $bc$. Para esto forzamos $bc$ como aceptación y consideramos los bucles necesarios.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a,c$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a,b,c$} ()
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q1) edge node [above] {$c$} (q2);
    \end{tikzpicture}
\end{basedtikz}
Ahora simplemente cambiamos los estados de aceptación, es decir $q_0$ y $q_1$ se vuelven de aceptación mientras que $q_2$ deja de serlo. De esta manera obtenemos el AFD que acepta el lenguaje deseado.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a,c$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a,b,c$} ()
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q1) edge node [above] {$c$} (q2);
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 2: }El lenguaje de todas las cadenas que no tienen tres unos consecutivos. Alfabeto: $\{0,1\}$. \\

Primero construyamos el AFD que acepte todas las cadenas con tres unos consecutivos.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0$} ()
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge node [above] {$1$} (q3)
        (q2) edge [bend left=60] node [below] {$0$} (q0)
        (q3) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
 
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0$} ()
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge node [above] {$1$} (q3)
        (q2) edge [bend left=60] node [below] {$0$} (q0)
        (q3) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}


\textbf{Punto 3: }El lenguaje de todas las cadenas que no terminan en 01. Alfabeto: $\{0,1\}$. \\

Primero construyamos el AFD que acepta todas las cadenas que terminan en 01.
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q0) edge node [above] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q0) edge node [above] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0);
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 4: }El lenguaje de todas las cadenas que no terminan en 22. Alfabeto: $\{0,1,2\}$. \\

Primero construyamos el AFD que acepta todas las cadenas que terminan en 22.
 
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0,1$} ()
        (q2) edge [loop above] node [above] {$2$} ()
        (q0) edge [bend left] node [above] {$2$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0)
        (q1) edge node [above] {$2$} (q2)
        (q2) edge [bend left=60] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0,1$} ()
        (q2) edge [loop above] node [above] {$2$} ()
        (q0) edge [bend left] node [above] {$2$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0)
        (q1) edge node [above] {$2$} (q2)
        (q2) edge [bend left=60] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}

Note que en los puntos 1 y 2, los estados $q_2$ y $q_3$ se volvieron limbo respectivamente y es posible quitarlos para una presentación simplificada del AFD, pero es preferible no retirarlos con el propósito de observar correctamente el proceso del complemento.

$\hfill \blacklozenge$ 

\section{Producto cartesiano de autómatas deterministas}

En esta sección observaremos otra manera de construir AFD para lenguajes que tengan dos condiciones los cuales puede que sean complicados por simple inspección, pero que con el algoritmo, se facilita muchísimo.\\

\textbf{Punto 1: }Utilizar el Teorema 2.11.1 (iii) para construir un AFD que acepte el lenguaje $L$ de todas las cadenas sobre el alfabeto $\Sigma=\{a,b\}$ que tienen longitud impar y que no contienen dos $b$es consecutivas, expresando $L$ como diferencia de dos lenguajes.\\

Primero considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud impar):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b$} (q1)
        (q1) edge [bend left] node [below] {$a,b$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora construyamos el AFD $M_2$ que acepta $L_2$ (las cadenas que contienen dos $bes$ consecutivas):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$a$} ()
        (q2) edge [bend left] node [above] {$b$} (q3)
        (q3) edge [bend left] node [below] {$a$} (q2)
        (q3) edge node [above] {$b$} (q4)
        (q4) edge [loop above] node [above] {$a,b$} ();
    \end{tikzpicture}
\end{basedtikz}

Entonces $L=L(M_1)-L(M_2)=L_1-L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_1,q_2)$ y $(q_1,q_3)$ Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \node (q04) [state, right of=q13] {$(q_0,q_4)$};
        \node (q14) [state, right of=q04] {$(q_1,q_4)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$a$} (q12)
        (q12) edge [bend left] node [below] {$a$} (q02)
        (q03) edge [bend left] node [below] {$a$} (q12)
        (q02) edge [bend right] node [left] {$b$} (q13)
        (q13) edge [bend right] node [right] {$a$} (q02)
        (q12) edge [bend left] node [above] {$b$} (q03)
        (q13) edge node [above] {$b$} (q04)
        (q03) edge node [right] {$b$} (q14)
        (q04) edge [bend left] node [above] {$a,b$} (q14)
        (q14) edge [bend left] node [below] {$a,b$} (q04);
        \end{tikzpicture}
\end{basedtikz}
Note que los estados $(q_0,q_4)$ y $(q_1,q_4)$ son estados limbo, así el autómata simplificado es el siguiente:
 
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$a$} (q12)
        (q12) edge [bend left] node [below] {$a$} (q02)
        (q03) edge [bend left] node [below] {$a$} (q12)
        (q02) edge [bend right] node [left] {$b$} (q13)
        (q13) edge [bend right] node [right] {$a$} (q02)
        (q12) edge [bend left] node [above] {$b$} (q03);
        \end{tikzpicture}
\end{basedtikz}
Observe que la solución presentada es igual a la del ejemplo correspondiente a este lenguaje, salvo la posición de los estados.\\

\textbf{Punto 2: }Utilizar el Teorema 2.11.1 para construir AFD que acepten los siguientes lenguajes sobre el alfabeto $\{0,1\}$:
\begin{itemize}[label={$\bullet$}]
    \item El lenguaje $L$ de todas las cadenas que tienen longitud par o que terminan en 10.\\

    Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud par):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que terminan en $10$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$0$} ()
        (q2) edge node [above] {$1$} (q3)
        (q3) edge [loop above] node [above] {$1$} ()
        (q3) edge [bend left] node [above] {$0$} (q4)
        (q4) edge [bend left=60] node [below] {$0$} (q2)
        (q4) edge [bend left] node [below] {$1$} (q3);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cup L(M_2)=L_1\cup L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_0,q_2),(q_0,q_3),(q_0,q_4)$ y $(q_1,q_4)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial, accepting] {$(q_0,q_2)$};
        \node (q14) [state, above right of=q02, accepting] {$(q_1,q_4)$};
        \node (q12) [state, above left of=q14] {$(q_1,q_2)$};
        \node (q03) [state, right of=q14, accepting] {$(q_0,q_3)$};
        \node (q13) [state, below right of=q03] {$(q_1,q_3)$};
        \node (q04) [state, above right of=q03, accepting] {$(q_0,q_4)$};
        \path [thick]
        (q02) edge [bend left] node [left] {$0$} (q12)
        (q12) edge [bend left] node [right] {$0$} (q02)
        (q13) edge [bend left] node [left] {$0$} (q04)
        (q04) edge [bend left] node [right] {$1$} (q13)
        (q14) edge [bend left] node [above] {$1$} (q03)
        (q03) edge [bend left] node [below] {$0$} (q14)
        (q04) edge [bend right=15] node [above] {$0$} (q12)
        (q12) edge [bend left=25] node [above] {$1$} (q03)
        (q14) edge node [above] {$0$} (q02)
        (q03) edge node [above] {$1$} (q13)
        (q02) edge  node [below] {$1$} (q13)
        (q13) edge [bend left] node [below] {$1$} (q03) ;
        \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen longitud impar y que terminan en 01.\\ 

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud impar):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que terminan en $01$):
 
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$1$} ()
        (q2) edge node [above] {$0$} (q3)
        (q3) edge [loop above] node [above] {$0$} ()
        (q3) edge [bend left] node [above] {$1$} (q4)
        (q4) edge [bend left=60] node [below] {$1$} (q2)
        (q4) edge [bend left] node [below] {$0$} (q3);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde el único estado de aceptación es $(q_1,q_4)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q14) [state, above right of=q02, accepting] {$(q_1,q_4)$};
        \node (q12) [state, above left of=q14] {$(q_1,q_2)$};
        \node (q03) [state, right of=q14] {$(q_0,q_3)$};
        \node (q13) [state, below right of=q03] {$(q_1,q_3)$};
        \node (q04) [state, above right of=q03] {$(q_0,q_4)$};
        \path [thick]
        (q02) edge [bend left] node [left] {$1$} (q12)
        (q12) edge [bend left] node [right] {$1$} (q02)
        (q13) edge [bend left] node [left] {$1$} (q04)
        (q04) edge [bend left] node [right] {$0$} (q13)
        (q14) edge [bend left] node [above] {$0$} (q03)
        (q03) edge [bend left] node [below] {$1$} (q14)
        (q04) edge [bend right=15] node [above] {$1$} (q12)
        (q12) edge [bend left=25] node [above] {$0$} (q03)
        (q14) edge node [above] {$1$} (q02)
        (q03) edge node [above] {$0$} (q13)
        (q02) edge  node [below] {$0$} (q13)
        (q13) edge [bend left] node [below] {$0$} (q03) ;
        \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen longitud impar y que no terminan en 11.\\

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud impar):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que no terminan en $11$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, right of=q3] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$0$} ()
        (q3) edge node [above] {$1$} (q4)
        (q4) edge [loop above] node [above] {$1$} ()
        (q2) edge [bend left] node [above] {$1$} (q3)
        (q4) edge [bend left=60] node [below] {$0$} (q2)
        (q3) edge [bend left] node [below] {$0$} (q2);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_1,q_2)$ y $(q_1,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \node (q14) [state, right of=q03] {$(q_1,q_4)$};
        \node (q04) [state, below of=q14] {$(q_0,q_4)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$0$} (q12)
        (q12) edge [bend left] node [below] {$0$} (q02)
        (q03) edge [bend left] node [below] {$0$} (q12)
        (q02) edge [bend right] node [left] {$1$} (q13)
        (q13) edge [bend right] node [right] {$0$} (q02)
        (q12) edge [bend left] node [above] {$1$} (q03)
        (q13) edge node [below] {$1$} (q04)
        (q03) edge node [above] {$1$} (q14)
        (q14) edge [bend right=50] node [above] {$0$} (q02)
        (q04) edge [bend left=15] node [below] {$0$} (q12)
        (q04) edge [bend left] node [left] {$1$} (q14)
        (q14) edge [bend left] node [right] {$1$} (q04);
        \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen un numero par de ceros o que no tienen dos ceros consecutivos.\\

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen un numero par de ceros):
 
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$1$} ()
        (q1) edge [bend left] node [below] {$0$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que no tienen dos ceros consecutivos):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, right of=q3] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$1$} ()
        (q2) edge [bend left] node [above] {$0$} (q3)
        (q3) edge [bend left] node [below] {$1$} (q2)
        (q3) edge node [above] {$0$} (q4)
        (q4) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cup L(M_2)=L_1\cup L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2)$ y $(q_1,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial, accepting] {$(q_0,q_2)$};
        \node (q13) [state, right of=q02, accepting] {$(q_1,q_3)$};
        \node (q04) [state, right of=q13, accepting] {$(q_0,q_4)$};
        \node (q03) [state, below of=q02, accepting] {$(q_0,q_3)$};
        \node (q12) [state, right of=q03, accepting] {$(q_1,q_2)$};
        \node (q14) [state, right of=q12] {$(q_1,q_4)$};
        \path[thick]
        (q02) edge [loop above] node [above] {$1$} ()
        (q04) edge [loop above] node [above] {$1$} ()
        (q12) edge [loop right] node [right] {$1$} ()
        (q14) edge [loop right] node [right] {$1$} ()
        (q02) edge node [above] {$0$} (q13)
        (q13) edge node [above] {$0$} (q04)
        (q13) edge node [right] {$1$} (q12)
        (q12) edge node [below] {$0$} (q03)
        (q03) edge node [left] {$1$} (q02)
        (q03) edge [bend right] node [below] {$0$} (q14)
        (q04) edge [bend left] node [right] {$0$} (q14)
        (q14) edge [bend left] node [left] {$0$} (q04);
        \end{tikzpicture}
\end{basedtikz}
\end{itemize}

\textbf{Punto 3: }Utilizar el Teorema 2.11.1 para construir AFD que acepten los siguientes lenguajes sobre el alfabeto $\{a,b,c\}$
\begin{itemize}[label={$\bullet$}]
    \item El lenguaje $L$ de todas las cadenas que tienen longitud par y terminan en $a.$\\

    Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud par):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b,c$} (q1)
        (q1) edge [bend left] node [below] {$a,b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que terminan en $a$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_2$};
        \node (q1) [state, right of=q0, accepting] {$q_3$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q0) edge [loop above] node [above] {$b,c$} ()
        (q1) edge [loop above] node [above] {$a$} ()
        (q1) edge [bend left] node [below] {$b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 4 estados: $(q_0,q_2),(q_0,q_3),(q_1,q_2)$ y $(q_1,q_3)$; donde el único estado de aceptación es $(q_0,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, below of=q02] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12, accepting] {$(q_0,q_3)$};
        \node (q13) [state, right of=q02] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$a$} (q13)
        (q13) edge [bend left] node [below] {$b,c$} (q02)
        (q02) edge [bend right] node [left] {$b,c$} (q12)
        (q12) edge [bend right] node [right] {$b,c$} (q02)
        (q13) edge [bend left] node [right] {$a$} (q03)
        (q03) edge [bend left] node [left] {$a$} (q13)
        (q12) edge [bend right] node [below] {$a$} (q03)
        (q03) edge [bend right] node [above] {$b,c$} (q12);
    \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen longitud par o que tienen un numero impar de $c$'s.\\

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud par):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b,c$} (q1)
        (q1) edge [bend left] node [below] {$a,b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que tienen un numero impar de $ces$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_2$};
        \node (q1) [state, right of=q0, accepting] {$q_3$};
        \path[thick]
        (q0) edge [bend left] node [above] {$c$} (q1)
        (q0) edge [loop above] node [above] {$a,b$} ()
        (q1) edge [loop above] node [above] {$a,b$} ()
        (q1) edge [bend left] node [below] {$c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cup L(M_2)=L_1\cup L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 4 estados: $(q_0,q_2),(q_0,q_3),(q_1,q_2)$ y $(q_1,q_3)$; donde los estados de aceptación son $(q_0,q_2),(q_0,q_3)$ y $(q_1,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial, accepting] {$(q_0,q_2)$};
        \node (q12) [state, below of=q02] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12, accepting] {$(q_0,q_3)$};
        \node (q13) [state, right of=q02, accepting] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$c$} (q13)
        (q13) edge [bend left] node [below] {$c$} (q02)
        (q02) edge [bend right] node [left] {$a,b$} (q12)
        (q12) edge [bend right] node [right] {$a,b$} (q02)
        (q13) edge [bend left] node [right] {$a,b$} (q03)
        (q03) edge [bend left] node [left] {$a,b$} (q13)
        (q12) edge [bend right] node [below] {$c$} (q03)
        (q03) edge [bend right] node [above] {$c$} (q12);
    \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen longitud impar y que tienen un numero par de $c$es.\\

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud impar):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b,c$} (q1)
        (q1) edge [bend left] node [below] {$a,b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que tienen un numero par de $ces$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_2$};
        \node (q1) [state, right of=q0] {$q_3$};
        \path[thick]
        (q0) edge [bend left] node [above] {$c$} (q1)
        (q0) edge [loop above] node [above] {$a,b$} ()
        (q1) edge [loop above] node [above] {$a,b$} ()
        (q1) edge [bend left] node [below] {$c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 4 estados: $(q_0,q_2),(q_0,q_3),(q_1,q_2)$ y $(q_1,q_3)$; donde el único estado de aceptación es $(q_1,q_2)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, below of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, right of=q02] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$c$} (q13)
        (q13) edge [bend left] node [below] {$c$} (q02)
        (q02) edge [bend right] node [left] {$a,b$} (q12)
        (q12) edge [bend right] node [right] {$a,b$} (q02)
        (q13) edge [bend left] node [right] {$a,b$} (q03)
        (q03) edge [bend left] node [left] {$a,b$} (q13)
        (q12) edge [bend right] node [below] {$c$} (q03)
        (q03) edge [bend right] node [above] {$c$} (q12);
    \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas que tienen longitud impar y que no terminan en $c.$\\

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud impar):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b,c$} (q1)
        (q1) edge [bend left] node [below] {$a,b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que no terminan en $c$):
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_2$};
        \node (q1) [state, right of=q0] {$q_3$};
        \path[thick]
        (q0) edge [bend left] node [above] {$c$} (q1)
        (q0) edge [loop above] node [above] {$a,b$} ()
        (q1) edge [loop above] node [above] {$c$} ()
        (q1) edge [bend left] node [below] {$a,b$} (q0);
    \end{tikzpicture}
\end{basedtikz}

Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 4 estados: $(q_0,q_2),(q_0,q_3),(q_1,q_2)$ y $(q_1,q_3)$; donde el único estado de aceptación es $(q_1,q_2)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:

\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, below of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, right of=q02] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$c$} (q13)
        (q13) edge [bend left] node [below] {$a,b$} (q02)
        (q02) edge [bend right] node [left] {$a,b$} (q12)
        (q12) edge [bend right] node [right] {$a,b$} (q02)
        (q13) edge [bend left] node [right] {$c$} (q03)
        (q03) edge [bend left] node [left] {$c$} (q13)
        (q12) edge [bend right] node [below] {$c$} (q03)
        (q03) edge [bend right] node [above] {$a,b$} (q12);
    \end{tikzpicture}
\end{basedtikz}
\item El lenguaje $L$ de todas las cadenas de longitud impar que tengan exactamente dos $a$es.\\ 

Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud impar):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b,c$} (q1)
        (q1) edge [bend left] node [below] {$a,b,c$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que tienen exactamente dos $aes$):
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$b,c$} ()
        (q3) edge [loop above] node [above] {$b,c$} ()
        (q4) edge [loop above] node [above] {$b,c$} ()
        (q2) edge node [above] {$a$} (q3)
        (q3) edge node [above] {$a$} (q4);
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$ (Note que como usamos la construcción de intersección podemos ignorar el estado limbo no representado en $M_2$); donde el único estado de aceptación es $(q_1,q_4)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, below of=q02] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, right of=q02] {$(q_1,q_3)$};
        \node (q14) [state, right of=q03, accepting] {$(q_1,q_4)$};
        \node (q04) [state, right of=q13] {$(q_0,q_4)$};
        \path[thick]
        (q02) edge [bend right] node [left] {$b,c$} (q12)
        (q12) edge [bend right] node [right] {$b,c$} (q02)
        (q13) edge [bend right] node [left] {$b,c$} (q03)
        (q03) edge [bend right] node [right] {$b,c$} (q13)
        (q04) edge [bend right] node [left] {$b,c$} (q14)
        (q14) edge [bend right] node [right] {$b,c$} (q04)
        (q02) edge node [above] {$a$} (q13)
        (q13) edge node [above] {$a$} (q04)
        (q12) edge node [below] {$a$} (q03)
        (q03) edge node [below] {$a$} (q14);
        \end{tikzpicture}
\end{basedtikz}
\end{itemize}
\textbf{Punto 4: }En el contexto del Teorema 2.11.1, dados dos AFD, $M_1=\left(\Sigma, Q_1, q_1, F_1, \delta_1\right)$ y $M_2=$ $\left(\Sigma, Q_2, q_2, F_2, \delta_2\right)$ tales que $L\left(M_1\right)=L_1$ y $L\left(M_2\right)=L_2$, escoger adecuadamente el conjunto de estados de aceptación $F$ para que el producto cartesiano $M_1 \times M_2=$ $\left(\Sigma, Q_1 \times Q_2,\left(q_1, q_2\right), F, \delta\right)$ acepte la diferencia simétrica $L_1 \triangleleft L_2$. Recuérdese que la diferencia simétrica se define como
$$
L_1 \triangleleft L_2=\left(L_1 \cup L_2\right)-\left(L_1 \cap L_2\right)=\left(L_1-L_2\right) \cup\left(L_2-L_1\right) .
$$
Por el teorema presentado en la sección sabemos que el conjunto que acepta $L_1-L_2$ es:
$$F_1\times(Q_2-F_2)$$
Mientras que el que acepta $L_2-L_1$ es:
$$F_2\times(Q_1-F_1)$$
Ahora como $L_1\triangleleft L_2=(L_1-L_2)\cup(L_2-L_1)$ Basta con unir las dos expresiones anteriores para obtener el conjunto adecuado de estados de aceptación; es decir:
$$F=(F_1\times(Q_2-F_2))\cup(F_2\times(Q_1-F_1)).$$

$\hfill \blacklozenge$

\section{Teorema de Kleene, parte I}

\textit{Siempre se puede construir un AFN-$\lambda$ si conocemos la expresión regular.} Es la lección de esta sección; siguiendo unos simples pasos y siendo bastante organizados podemos construir un AFN-$\lambda$ dada una expresión regular y por tanto siempre podremos llegar a un AFD por los métodos de conversión ya presentados previamente.\\

Utilizar el procedimiento del Teorema 2.12.1 para construir AFN-$\lambda$ que acepten los siguientes lenguajes sobre el alfabeto $\{a,b,c\}.$\\
\textbf{Punto 1: }$(a^*c)^*\cup(b^*a)^*(ca^*)^*b^+.$
\begin{itemize}
    \item[i)] Autómata que acepta $a^*c$:
    \begin{basedtikz}
    \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [loop above] node [above] {$a$}
            (q0) edge [bend left] node [above] {$c$}  (q1); 
         \end{tikzpicture}
     \end{basedtikz} 
     \item[ii)] Autómata que acepta $(a^*c)^*$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q2) [state, initial, accepting, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q0) edge [loop above] node [above] {$a$}
            (q0) edge [bend left] node [above] {$c$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0); 
         \end{tikzpicture}
     \end{basedtikz}
     \item[iii)] Autómata que acepta $(b^*a)^*$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q2) [state, initial, accepting, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q0) edge [loop above] node [above] {$b$}
            (q0) edge [bend left] node [above] {$a$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0); 
         \end{tikzpicture}
     \end{basedtikz}
     \item[iv)] Autómata que acepta $(ca^*)^*$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q2) [state, initial, accepting, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q1) edge [loop above] node [above] {$a$} ()
            (q0) edge [bend left] node [above] {$c$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0); 
         \end{tikzpicture}
     \end{basedtikz}

     \item[v)] Autómata que acepta $(b^*a)^*(ca^*)^*$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q2) [state, initial, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q3) [state, right of=q1, accepting, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, right of=q4, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q0) edge [loop above] node [above] {$b$}
            (q0) edge [bend left] node [above] {$a$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0)
            (q2) edge [bend right=40] node [below] {$\lambda$} (q3)
            (q1) edge [bend left] node [above] {$\lambda$} (q3)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q5) edge [loop above] node [above] {$a$} ()
            (q4) edge [bend left] node [above] {$c$}  (q5)
            (q5) edge [bend left] node [below] {$\lambda$} (q4); 
         \end{tikzpicture}
     \end{basedtikz}
     \item[vi)] Autómata que acepta $(b^*a)^*(ca^*)^*b^+$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q2) [state, initial, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q3) [state, right of=q1, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, right of=q4, minimum size=15pt] {};
            \node (q6) [state, right of=q5, minimum size=15pt] {};
            \node (q7) [state, right of=q6, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q0) edge [loop above] node [above] {$b$} ()
            (q0) edge [bend left] node [above] {$a$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0)
            (q2) edge [bend right=40] node [below] {$\lambda$} (q3)
            (q1) edge [bend left] node [above] {$\lambda$} (q3)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q5) edge [loop above] node [above] {$a$} ()
            (q4) edge [bend left] node [above] {$c$}  (q5)
            (q5) edge [bend left] node [below] {$\lambda$} (q4)
            (q3) edge [bend right=40] node [below] {$\lambda$} (q6) 
            (q5) edge [bend left] node [above] {$\lambda$} (q6)
            (q6) edge [bend left] node [above] {$b$} (q7)
            (q7) edge [loop above] node [above] {$b$} ();
         \end{tikzpicture}
     \end{basedtikz}
     \item[vii)] Autómata que acepta $(a^*c)^*\cup(b^*a)^*(ca^*)^*b^+$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q8) [state, initial, minimum size=15pt] {};
            \node (q9) [state, above right of=q8, accepting, minimum size=15pt] {};
            \node (q10) [state, right of=q9, minimum size=15pt] {};
            \node (q11) [state, right of=q10, accepting, minimum size=15pt] {};
            \node (q2) [state, below right of=q8, minimum size=15pt] {};
            \node (q0) [state, right of=q2, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q3) [state, right of=q1, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, right of=q4, minimum size=15pt] {};
            \node (q6) [state, right of=q5, minimum size=15pt] {};
            \node (q7) [state, right of=q6, accepting, minimum size=15pt] {};
            \path[thick]
            (q2) edge [bend left] node [above] {$\lambda$} (q0)
            (q0) edge [loop above] node [above] {$b$} ()
            (q0) edge [bend left] node [above] {$a$}  (q1)
            (q1) edge [bend left] node [below] {$\lambda$} (q0)
            (q2) edge [bend right=40] node [below] {$\lambda$} (q3)
            (q1) edge [bend left] node [above] {$\lambda$} (q3)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q5) edge [loop above] node [above] {$a$} ()
            (q4) edge [bend left] node [above] {$c$}  (q5)
            (q5) edge [bend left] node [below] {$\lambda$} (q4)
            (q3) edge [bend right=40] node [below] {$\lambda$} (q6) 
            (q5) edge [bend left] node [above] {$\lambda$} (q6)
            (q6) edge [bend left] node [above] {$b$} (q7)
            (q7) edge [loop above] node [above] {$b$} ()
            (q8) edge [bend right] node [below] {$\lambda$} (q2)
            (q8) edge [bend left] node [above] {$\lambda$} (q9)
            (q9) edge [bend left] node [above] {$\lambda$} (q10)
            (q10) edge [loop above] node [above] {$a$}
            (q10) edge [bend left] node [above] {$c$}  (q11)
            (q11) edge [bend left] node [below] {$\lambda$} (q10);
         \end{tikzpicture}
     \end{basedtikz}
\end{itemize}
\textbf{Punto 2: }$(a^*cb)^*(a\cup b)(a\cup bc)^*.$
\begin{itemize}
    \item[i)] Autómata que acepta $(a^*cb)^*$
     
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, accepting, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [loop above] node [above] {$a$} ()
            (q1) edge [bend left] node [above] {$c$} (q2)
            (q2) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend left=40] node [below] {$\lambda$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \item[ii)] Autómata que acepta $(a^*cb)^*(a\cup b)$
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, above right of=q4, accepting, minimum size=15pt] {};
            \node (q6) [state, below right of=q4, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [loop above] node [above] {$a$} ()
            (q1) edge [bend left] node [above] {$c$} (q2)
            (q2) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend left=40] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=50] node [below] {$\lambda$} (q4)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q4) edge [bend left] node [above] {$a$} (q5)
            (q4) edge [bend right] node [below] {$b$} (q6);
        \end{tikzpicture}
    \end{basedtikz}
    \item[iii)] Autómata que acepta $(a^*cb)^*(a\cup b)(a\cup bc)^*$
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, above right of=q4, minimum size=15pt] {};
            \node (q6) [state, below right of=q4, minimum size=15pt] {};
            \node (q7) [state, below right of=q5, accepting, minimum size=15pt] {};
            \node (q8) [state, right of=q7, minimum size=15pt] {};
            \node (q9) [state, above right of=q8, accepting, minimum size=15pt] {};
            \node (q10) [state, below right of=q8, minimum size=15pt] {};
            \node (q11) [state, right of=q10, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [loop above] node [above] {$a$} ()
            (q1) edge [bend left] node [above] {$c$} (q2)
            (q2) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend left=40] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=50] node [below] {$\lambda$} (q4)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q4) edge [bend left] node [above] {$a$} (q5)
            (q4) edge [bend right] node [below] {$b$} (q6)
            (q5) edge [bend left] node [above] {$\lambda$} (q7)
            (q6) edge [bend right] node [below] {$\lambda$} (q7)
            (q7) edge [bend left] node [above] {$\lambda$} (q8)
            (q8) edge [bend left] node [above] {$a$} (q9)
            (q9) edge [bend left] node [below] {$\lambda$} (q8)
            (q8) edge [bend right] node [above] {$b$} (q10)
            (q10) edge [bend left] node [above] {$c$} (q11)
            (q11) edge [bend left=80] node [below] {$\lambda$} (q8);
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}
\textbf{Punto 3: }$(a\cup ba\cup ca)^*(\lambda\cup a)b^+c^+$.
\begin{itemize}
    \item[i)] Autómata que acepta $(a\cup ba\cup ca)^*$
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, accepting, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, accepting, minimum size=15pt] {};
            \node (q3) [state, above of=q2, minimum size=15pt] {};
            \node (q4) [state, below of=q2, minimum size=15pt] {};
            \node (q5) [state, right of=q3, accepting, minimum size=15pt] {};
            \node (q6) [state, right of=q4, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q2)
            (q2) edge [bend left] node [below] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend right] node [below] {$a$} (q5)
            (q5) edge [bend right=90] node [above] {$\lambda$} (q1)
            (q1) edge [bend right] node [below] {$c$} (q4)
            (q4) edge [bend left] node [above] {$a$} (q6)
            (q6) edge [bend left=90] node [below] {$\lambda$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \item[ii)] Autómata que acepta $(a\cup ba\cup ca)^*(\lambda\cup a)$
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, above of=q2, minimum size=15pt] {};
            \node (q4) [state, below of=q2, minimum size=15pt] {};
            \node (q5) [state, right of=q3, minimum size=15pt] {};
            \node (q6) [state, right of=q4, minimum size=15pt] {};
            \node (q7) [state, right of=q6, minimum size=15pt] {};
            \node (q8) [state, right of=q7, accepting, minimum size=15pt] {};
            \node (q9) [state, above of=q8, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q2)
            (q2) edge [bend left] node [below] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend right] node [below] {$a$} (q5)
            (q5) edge [bend right=90] node [above] {$\lambda$} (q1)
            (q1) edge [bend right] node [below] {$c$} (q4)
            (q4) edge [bend left] node [above] {$a$} (q6)
            (q6) edge [bend left=90] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=110] node [below] {$\lambda$} (q7)
            (q2) edge [bend left] node [above] {$\lambda$} (q7)
            (q6) edge [bend right] node [below] {$\lambda$} (q7)
            (q5) edge [bend left] node [above] {$\lambda$} (q7)
            (q7) edge [bend left] node [above] {$a$} (q9)
            (q7) edge [bend right] node [below] {$\lambda$} (q8);
        \end{tikzpicture}
    \end{basedtikz}
    \item[iii)] Autómata que acepta $(a\cup ba\cup ca)^*(\lambda\cup a)b^+c^+$
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, above of=q2, minimum size=15pt] {};
            \node (q4) [state, below of=q2, minimum size=15pt] {};
            \node (q5) [state, right of=q3, minimum size=15pt] {};
            \node (q6) [state, right of=q4, minimum size=15pt] {};
            \node (q7) [state, right of=q6, minimum size=15pt] {};
            \node (q8) [state, right of=q7, minimum size=15pt] {};
            \node (q9) [state, above of=q8, minimum size=15pt] {};
            \node (q10) [state, right of=q9, minimum size=15pt] {};
            \node (q11) [state, right of=q10, minimum size=15pt] {};
            \node (q12) [state, right of=q11, minimum size=15pt] {};
            \node (q13) [state, right of=q12, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q2)
            (q2) edge [bend left] node [below] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q3) edge [bend right] node [below] {$a$} (q5)
            (q5) edge [bend right=90] node [above] {$\lambda$} (q1)
            (q1) edge [bend right] node [below] {$c$} (q4)
            (q4) edge [bend left] node [above] {$a$} (q6)
            (q6) edge [bend left=90] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=110] node [below] {$\lambda$} (q7)
            (q2) edge [bend left] node [above] {$\lambda$} (q7)
            (q6) edge [bend right] node [below] {$\lambda$} (q7)
            (q5) edge [bend left] node [above] {$\lambda$} (q7)
            (q7) edge [bend left] node [above] {$a$} (q9)
            (q7) edge [bend right] node [below] {$\lambda$} (q8)
            (q8) edge [bend right] node [below] {$\lambda$} (q10)
            (q9) edge [bend left] node [above] {$\lambda$} (q10)
            (q10) edge [bend left] node [above] {$b$} (q11)
            (q11) edge [loop above] node [above] {$b$} ()
            (q11) edge [bend left] node [above] {$\lambda$} (q12)
            (q12) edge [bend left] node [above] {$c$} (q13)
            (q13) edge [loop above] node [above] {$c$} ();
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}
\textbf{Punto 4: }$(a^*bc)^*\cup(cb^*a)^+\cup(ca\cup cb\cup c^2)^*a^*b^+.$
\begin{itemize}
    \item[i)] Autómata que acepta $(a^*bc)^*$
    \begin{basedtikz}
    \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, accepting, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [loop above] node [above] {$a$}
            (q1) edge [bend left] node [above] {$b$}  (q2)
            (q2) edge [bend left] node [above] {$c$}  (q3)
            (q3) edge [bend left] node [below] {$\lambda$} (q1); 
         \end{tikzpicture}
     \end{basedtikz}
     \item[ii)] Autómata que acepta $(cb^*a)^+$
      \begin{basedtikz}
      \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$c$} (q1)
            (q1) edge [loop above] node [above] {$b$}
            (q1) edge [bend left] node [above] {$a$}  (q2)
            (q2) edge [bend left] node [below] {$\lambda$} (q0); 
         \end{tikzpicture}
     \end{basedtikz}
     \item[iii)] Autómata que acepta $(ca\cup cb\cup c^2)^*a^*b^+$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, right of=q4, minimum size=15pt, accepting] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$c$} (q2)
            (q2) edge [bend left] node [above] {$a,b,c$} (q3)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q4) edge [bend left] node [above] {$b$} (q5)
            (q4) edge [loop above] node [above] {$a$} ()
            (q5) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=45] node [below] {$\lambda$} (q4);
         \end{tikzpicture}
     \end{basedtikz}
     \item[iv)] Autómata que acepta $(a^*bc)^*\cup(cb^*a)^+\cup(ca\cup cb\cup c^2)^*a^*b^+$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (qa) [state, initial, minimum size=15pt] {};

            \node (q6) [state, right of=qa, minimum size=15pt] {};
            \node (q7) [state, right of=q6, minimum size=15pt] {};
            \node (q8) [state, right of=q7, accepting, minimum size=15pt] {};
            

            \node (q0) [state, below of=q6, minimum size=15pt] {};
            \node (q1) [state, right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, right of=q4, minimum size=15pt, accepting] {};

            \node (q9) [state, above of=q6, accepting, minimum size=15pt] {};
            \node (q10) [state, right of=q9, minimum size=15pt] {};
            \node (q11) [state, right of=q10, minimum size=15pt] {};
            \node (q12) [state, right of=q11, accepting, minimum size=15pt] {};

            \path[thick]
            (qa) edge [bend left] node [above] {$\lambda$} (q9)
            (qa) edge node [above] {$\lambda$} (q6)
            (qa) edge [bend right] node [below] {$\lambda$} (q0)
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q1) edge [bend left] node [above] {$c$} (q2)
            (q2) edge [bend left] node [above] {$a,b,c$} (q3)
            (q3) edge [bend left] node [above] {$\lambda$} (q4)
            (q4) edge [bend left] node [above] {$b$} (q5)
            (q4) edge [loop above] node [above] {$a$} ()
            (q5) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [below] {$\lambda$} (q1)
            (q0) edge [bend right=45] node [below] {$\lambda$} (q4)
            (q6) edge [bend left] node [above] {$c$} (q7)
            (q7) edge [loop above] node [above] {$b$}
            (q7) edge [bend left] node [above] {$a$}  (q8)
            (q8) edge [bend left] node [below] {$\lambda$} (q6)
            (q9) edge [bend left] node [above] {$\lambda$} (q10)
            (q10) edge [loop above] node [above] {$a$}
            (q10) edge [bend left] node [above] {$b$}  (q11)
            (q11) edge [bend left] node [above] {$c$}  (q12)
            (q12) edge [bend left] node [below] {$\lambda$} (q10);
         \end{tikzpicture}
     \end{basedtikz}
\end{itemize}
\textbf{Punto 5: }$a^*b^*(ca^+\cup b\cup\lambda)(b\cup bc)^*\cup(b\cup\lambda)(b^*ac)^*.$
\begin{itemize}
    \item[i)] Autómata que acepta $a^*b^*(ca^+\cup b\cup\lambda)(b\cup bc)^*$
     
    \begin{basedtikz}
    \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q1) [state, initial, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, above right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, below right of=q2, minimum size=15pt] {};
            \node (q6) [state, right of=q5, accepting, minimum size=15pt] {};
            \node (q7) [state, right of=q6, minimum size=15pt] {};
            \node (q8) [state, right of=q7, minimum size=15pt] {};
            \node (q9) [state, right of=q8, accepting, minimum size=15pt] {};
            \path[thick]
            (q1) edge [loop above] node [above] {$a$} ()
            (q2) edge [loop right] node [right] {$b$} ()
            (q1) edge [bend left] node [above] {$\lambda$} (q2)
            (q2) edge [bend left] node [above] {$c$} (q3)
            (q3) edge [bend left] node [above] {$a$} (q4)
            (q4) edge [loop above] node [above] {$a$} ()
            (q2) edge [bend right] node [below] {$b,\lambda$} (q5)
            (q4) edge node [right] {$\lambda$} (q6)
            (q5) edge [bend left] node [above] {$\lambda$} (q6)
            (q6) edge [bend left] node [above] {$\lambda$} (q7)
            (q7) edge [bend left] node [above] {$b$} (q8)
            (q8) edge [bend left] node [above] {$c,\lambda$} (q9)
            (q9) edge [bend left] node [below] {$\lambda$} (q7);
         \end{tikzpicture}
     \end{basedtikz}
    \item[ii)] Autómata que acepta $(b\cup\lambda)(b^*ac)^*$
    \begin{basedtikz}
    \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q10) [state, initial, minimum size=15pt] {};
            \node (q11) [state, right of=q10, accepting, minimum size=15pt] {};
            \node (q12) [state, right of=q11, minimum size=15pt] {};
            \node (q13) [state, right of=q12, minimum size=15pt] {};
            \node (q14) [state, right of=q13, accepting, minimum size=15pt] {};
            \path[thick]
            (q10) edge [bend left] node [above] {$b,\lambda$} (q11)
            (q11) edge [bend left] node [above] {$\lambda$} (q12)
            (q12) edge [loop above] node [above] {$b$} ()
            (q12) edge [bend left] node [above] {$a$} (q13)
            (q13) edge [bend left] node [above] {$c$} (q14)
            (q14) edge [bend left] node [below] {$\lambda$} (q12);
         \end{tikzpicture}
     \end{basedtikz}
     \item[iii)] Autómata que acepta $a^*b^*(ca^+\cup b\cup\lambda)(b\cup bc)^*\cup(b\cup\lambda)(b^*ac)^*$
     \begin{basedtikz}
     \centering
         \begin{tikzpicture}[node distance = 1.5cm, on grid, auto]
            \node (q0) [state, initial, minimum size=15pt] {};
            \node (q1) [state, above right of=q0, minimum size=15pt] {};
            \node (q2) [state, right of=q1, minimum size=15pt] {};
            \node (q3) [state, above right of=q2, minimum size=15pt] {};
            \node (q4) [state, right of=q3, minimum size=15pt] {};
            \node (q5) [state, below right of=q2, minimum size=15pt] {};
            \node (q6) [state, right of=q5, accepting, minimum size=15pt] {};
            \node (q7) [state, right of=q6, minimum size=15pt] {};
            \node (q8) [state, right of=q7, minimum size=15pt] {};
            \node (q9) [state, right of=q8, accepting, minimum size=15pt] {};
            \node (q10) [state, below right of=q0, minimum size=15pt] {};
            \node (q11) [state, right of=q10, accepting, minimum size=15pt] {};
            \node (q12) [state, right of=q11, minimum size=15pt] {};
            \node (q13) [state, right of=q12, minimum size=15pt] {};
            \node (q14) [state, right of=q13, accepting, minimum size=15pt] {};
            \path[thick]
            (q0) edge [bend left] node [above] {$\lambda$} (q1)
            (q0) edge [bend right] node [below] {$\lambda$} (q10)
            (q1) edge [loop above] node [above] {$a$} ()
            (q2) edge [loop right] node [right] {$b$} ()
            (q1) edge [bend left] node [above] {$\lambda$} (q2)
            (q2) edge [bend left] node [above] {$c$} (q3)
            (q3) edge [bend left] node [above] {$a$} (q4)
            (q4) edge [loop above] node [above] {$a$} ()
            (q2) edge [bend right] node [left] {$b,\lambda$} (q5)
            (q4) edge node [right] {$\lambda$} (q6)
            (q5) edge [bend left] node [above] {$\lambda$} (q6)
            (q6) edge [bend left] node [above] {$\lambda$} (q7)
            (q7) edge [bend left] node [above] {$b$} (q8)
            (q8) edge [bend left] node [above] {$c,\lambda$} (q9)
            (q9) edge [bend left] node [below] {$\lambda$} (q7)
            (q10) edge [bend left] node [above] {$b,\lambda$} (q11)
            (q11) edge [bend left] node [above] {$\lambda$} (q12)
            (q12) edge [loop below] node [below] {$b$} ()
            (q12) edge [bend left] node [above] {$a$} (q13)
            (q13) edge [bend left] node [above] {$c$} (q14)
            (q14) edge [bend left] node [below] {$\lambda$} (q12);
         \end{tikzpicture}
     \end{basedtikz}
\end{itemize}

Cabe aclarar que las construcciones realizadas no son únicas ya que este procedimiento es bastante flexible, después de todo las construcciones presentadas aquí tienen bastantes simplificaciones.

$\hfill \blacklozenge$

\section{Teorema de Kleene, parte II}

\textit{Dado un Autómata Finito, siempre podemos encontrar una expresión regular que sea aceptada por el mismo.} Anteriormente nos dimos cuenta que habían problemas al momento de encontrar expresiones regulares para algunos lenguajes mientras que construir un autómata para el mismo era bastante sencillo, en esta sección se explora un algoritmo que nos permite hallar siempre la expresión regular de un lenguaje dado el autómata que acepta ese lenguaje.\\

\textbf{Punto 1: }Utilizar el procedimiento presentado en la presente sección para encontrar expresiones regulares para los lenguajes aceptados por los siguientes autómatas.
\begin{itemize}[label={$\bullet$}]
    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge node [above] {$b$} (q2)
            (q1) edge [loop above] node [above] {$b$} ()
            (q3) edge [loop above] node [above] {$b$} ()
            (q2) edge [bend left] node [below] {$a$} (q3)
            (q3) edge [bend left] node [below] {$b$} (q0);
            \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo:
    \begin{itemize}
        \item[i)] Eliminar estado $q_2$:
        \begin{basedtikz}
        \centering
          \begin{tikzpicture}[node distance = 3cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0, accepting] {$q_1$};
             \node (q3) [state, below of=q1] {$q_3$};
             \path[thick]
             (q0) edge node [above] {$a$} (q1)
             (q1) edge [loop above] node [above] {$b$} () 
             (q3) edge [loop above] node [above] {$b$} ()
             (q3) edge [bend left] node [left] {$b$} (q0)
             (q1) edge [bend left] node [right] {$ba$} (q3);  
             \end{tikzpicture}   
         \end{basedtikz} 
         \item[ii)] Eliminar estado $q_3$:
         \begin{basedtikz}
         \centering
          \begin{tikzpicture}[node distance = 3cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0, accepting] {$q_1$};
             \path[thick]
             (q0) edge [bend left] node [above] {$a$} (q1)
             (q1) edge [loop above] node [above] {$b$} ()
             (q1) edge [bend left] node [below] {$bab^*b$} (q0);  
             \end{tikzpicture}   
         \end{basedtikz}
    \end{itemize}
    Teniendo en cuenta que $b^*b=b^+$, por simple inspección obtenemos que:
    $$L(M)=a(b^*\cup bab^+a)^*$$
    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 3cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \node (q1) [state, above right of=q2, accepting] {$q_1$};
            \path[thick]
            (q0) edge [bend left=20] node [above] {$a$} (q1)
            (q1) edge [loop above] node [above] {$b$} ()
            (q2) edge node [below] {$a$} (q1)
            (q1) edge [bend left=20] node [below] {$a$} (q0)
            (q2) edge [bend left=20] node [below] {$b$} (q0)
            (q0) edge [bend left=20] node [right] {$b$} (q2);
            \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo,de paso lo acomodaremos de forma que sea mas sencillo trabajar:
    \begin{itemize}
        \item[i)] Agregamos un nuevo estado de aceptación $q$:
        \begin{basedtikz}
        \centering
          \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0] {$q_1$};
             \node (q2) [state, below of=q0] {$q_2$};
             \node (q) [state, right of=q2, accepting] {$q$};
             \path[thick]
             (q0) edge [bend left] node [above] {$a$} (q1)
             (q1) edge [bend left] node [below] {$a$} (q0)
             (q0) edge [bend left] node [right] {$b$} (q2)
             (q2) edge [bend left] node [left] {$b$} (q0) 
             (q1) edge [loop above] node [above] {$b$} ()
             (q2) edge node [below] {$a$} (q1)
             (q1) edge node [right] {$\lambda$} (q)
             (q2) edge node [above] {$\lambda$} (q); 
             \end{tikzpicture}   
         \end{basedtikz} 
         \item[ii)] Eliminar estado $q_2$:
         \begin{basedtikz}
         \centering
          \begin{tikzpicture}[node distance = 3cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0] {$q_1$};
             \node (q) [state, below of=q1, accepting] {$q$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b^2$} ()
             (q0) edge node [below] {$b$} (q)
             (q0) edge [bend left] node [above] {$a\cup ba$} (q1)
             (q1) edge [bend left] node [below] {$a$} (q0) 
             (q1) edge [loop above] node [above] {$b$} ()
             (q1) edge node [right] {$\lambda$} (q); 
             \end{tikzpicture}   
         \end{basedtikz} 
         \item[iii)] Eliminar estado $q_1$:
          
         \begin{basedtikz}
         \centering
         \begin{tikzpicture}[node distance = 4.5cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q) [state, right of=q0, accepting] {$q$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b^2\cup[(a\cup ba)b^*a]$} ()
             (q0) edge  node [above] {$b\cup(a\cup ba)b^*$} (q); 
             \end{tikzpicture}   
         \end{basedtikz} 
    \end{itemize}
    Ahora por simple inspección llegamos a que:
    $$L(M)=\left(b^2\cup[(a\cup ba)b^*a]\right)^*(b\cup(a\cup ba)b^*)$$
    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$b$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q2) edge [bend left] node [below] {$a$} (q1)
            (q2) edge [bend left=60] node [below] {$b$} (q0)
            (q1) edge [loop above] node [above] {$a$} ()
            (q2) edge [loop above] node [above] {$b$} ();
            \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo:
    \begin{itemize}
        \item[i)] Eliminar estado $q_1$ 
        \begin{basedtikz}
        \centering
         \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial, accepting] {$q_0$};
             \node (q2) [state, right of=q0, accepting] {$q_2$};
             \path[thick]
             (q0) edge [loop above] node [above] {$ba^*a$} ()
             (q0) edge [bend left] node [above] {$b\cup ba^*b$} (q2)
             (q2) edge [bend left] node [below] {$aa^*a$} (q0)
             (q2) edge [loop above] node [above] {$b\cup aa^*b$} ();
             \end{tikzpicture}   
         \end{basedtikz}
         \item[ii)] Agregamos un nuevo estado de aceptación $q$:
          
         \begin{basedtikz}
         \centering
         \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q2) [state, right of=q0] {$q_2$};
             \node (q) [state, below of=q2, accepting] {$q$}; 
             \path[thick]
             (q0) edge [loop above] node [above] {$ba^*a$} ()
             (q0) edge [bend left] node [above] {$b\cup ba^*b$} (q2)
             (q2) edge [bend left] node [below] {$aa^*a$} (q0)
             (q2) edge [loop above] node [above] {$b\cup aa^*b$} ()
             (q0) edge [bend right] node [below] {$\lambda$} (q)
             (q2) edge node [right] {$\lambda$} (q);
             \end{tikzpicture}   
         \end{basedtikz} 
         \item[iii)] Eliminar estado $q_2$:
         \begin{basedtikz}
         \centering
         \begin{tikzpicture}[node distance = 6cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q) [state, right of=q0, accepting] {$q$}; 
             \path[thick]
             (q0) edge [loop above] node [above] {$ba^*a\cup[(b\cup ba^*b)(b\cup aa^*b)^*aa^*a]$} ()
             (q0) edge node [above] {$\lambda\cup (b\cup ba^*b)(b\cup aa^*b)^*$} (q);
             \end{tikzpicture}   
         \end{basedtikz}
    \end{itemize}
    Teniendo en cuenta que $a^*a=aa^*=a^+$, por simple inspección obtenemos que:
    $$L(M)=\left(ba^*a\cup[(b\cup ba^*b)(b\cup aa^*b)^*aa^*a]\right)^*(\lambda\cup (b\cup ba^*b)(b\cup aa^*b)^*)$$

    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge node [above] {$b$} (q2)
            (q0) edge [loop above] node [above] {$b$} ()
            (q2) edge [loop above] node [above] {$a$} ()
            (q2) edge node [below] {$b$} (q3)
            (q3) edge node [below] {$a$} (q0)
            (q1) edge [bend left] node [below] {$a$} (q0);
            \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo:
    \begin{itemize}
        \item[i)] Eliminar estado $q_2$:
         
        \begin{basedtikz}
        \centering
          \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0, accepting] {$q_1$};
             \node (q3) [state, below of=q1, accepting] {$q_3$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b$} ()
             (q0) edge [bend left] node [above] {$a$} (q1)
             (q1) edge [bend left] node [below] {$a$} (q0)
             (q3) edge node [below] {$a$} (q0)
             (q1) edge node [right] {$ba^*b$} (q3);
             \end{tikzpicture}   
         \end{basedtikz} 
         \item[ii)] Agregamos un nuevo estado de aceptación $q$:
         \begin{basedtikz}
         \centering
          \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0] {$q_1$};
             \node (q3) [state, below of=q1] {$q_3$};
             \node (q) [state, right of=q1, accepting] {$q$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b$} ()
             (q0) edge [bend left] node [above] {$a$} (q1)
             (q1) edge [bend left] node [below] {$a$} (q0)
             (q3) edge node [below] {$a$} (q0)
             (q1) edge node [right] {$ba^*b$} (q3)
             (q1) edge node [above] {$\lambda$} (q)
             (q3) edge node [below] {$\lambda$} (q);
             \end{tikzpicture}   
         \end{basedtikz}
         \item[iii)] Eliminar estado $q_3$:
         \begin{basedtikz}
         \centering
          \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q1) [state, right of=q0] {$q_1$};
             \node (q) [state, right of=q1, accepting] {$q$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b$} ()
             (q0) edge [bend left] node [above] {$a$} (q1)
             (q1) edge [bend left] node [below] {$a\cup ba^*ba$} (q0)
             (q1) edge node [above] {$\lambda\cup ba^*b$} (q);
             \end{tikzpicture}  
         \end{basedtikz}
         \item[iv)] Eliminar estado $q_1$: 
          
         \begin{basedtikz}
         \centering
         \begin{tikzpicture}[node distance = 4cm, on grid, auto]
             \node (q0) [state, initial] {$q_0$};
             \node (q) [state, right of=q0, accepting] {$q$};
             \path[thick]
             (q0) edge [loop above] node [above] {$b\cup[a(a\cup ba^*ba)]$} ()
             (q0) edge node [above] {$a(\lambda\cup ba^*b)$} (q);
             \end{tikzpicture}  
         \end{basedtikz}      
    \end{itemize}
    Por simple inspección obtenemos que:
    $$L(M)=\left(b\cup[a(a\cup ba^*ba)]\right)^*\left(a(\lambda\cup ba^*b)\right)$$ 
    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1,accepting] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$a$} (q1)
        (q1) edge node [above] {$a$} (q2)
        (q2) edge [loop above] node [above] {$b$} ()
        (q2) edge node [above] {$b$} (q3)
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [bend left] node [below] {$a$} (q3)
        (q4) edge [bend left=60] node [below] {$a$} (q2);   
        \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo:
    \begin{itemize}
        \item[i)] Eliminar estado $q_1$:
        \begin{basedtikz}
        \centering
        \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state,  right of=q0,accepting] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$aa$} (q2)
        (q2) edge [loop above] node [above] {$b$} ()
        (q2) edge node [above] {$b$} (q3)
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [bend left] node [below] {$a$} (q3)
        (q4) edge [bend left=60] node [below] {$a$} (q2);   
        \end{tikzpicture}
    \end{basedtikz}
    \item[ii)] Eliminar estado $q_3$:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state,  right of=q0,accepting] {$q_2$};
        \node (q4) [state, right of=q2, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$aa$} (q2)
        (q2) edge [loop above] node [above] {$b$} ()
        (q2) edge [bend left] node [above] {$ba^*b$} (q4)
        (q4) edge [loop above] node [above] {$aa^*b$} ()
        (q4) edge [bend left] node [below] {$a$} (q2);   
        \end{tikzpicture}
    \end{basedtikz}
    \item[iii)] Agregamos un nuevo estado de aceptación $q$:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state,  right of=q0] {$q_2$};
        \node (q4) [state, right of=q2] {$q_4$};
        \node (q) [state, below of=q2, accepting] {$q$};
        \path[thick]
        (q0) edge node [above] {$aa$} (q2)
        (q2) edge [loop above] node [above] {$b$} ()
        (q2) edge [bend left] node [above] {$ba^*b$} (q4)
        (q4) edge [loop above] node [above] {$aa^*b$} ()
        (q4) edge [bend left] node [below] {$a$} (q2)
        (q2) edge node [left] {$\lambda$} (q)
        (q4) edge node [right] {$\lambda$} (q);   
        \end{tikzpicture}
    \end{basedtikz}
    \item[iv)] Eliminar estado $q_4$:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state,  right of=q0] {$q_2$};
        \node (q) [state, below of=q2, accepting] {$q$};
        \path[thick]
        (q0) edge node [above] {$aa$} (q2)
        (q2) edge [loop above] node [above] {$b\cup[ba^*b(aa^*b)^*a]$} ()
        (q2) edge node [left] {$\lambda\cup[ba^*b(aa^*b)^*]$} (q);   
        \end{tikzpicture}
    \end{basedtikz}
    \item[v)] Eliminar estado $q_2$:
    \begin{basedtikz}
    \centering
        \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q) [state, right of=q0, accepting] {$q$};
        \path[thick]
        (q0) edge [bend left] node [above] {$aa\left(b\cup[ba^*b(aa^*b)^*a]\right)^*(\lambda\cup[ba^*b(aa^*b)^*])$} (q);   
        \end{tikzpicture}
    \end{basedtikz}
    \end{itemize}
    Realizando las respectivas simplificaciones y por simple inspección obtenemos que:
    $$L(M)=a^2\left(b\cup[ba^*b(a^+b)^*a]\right)^*(\lambda\cup[ba^*b(a^+b)^*])$$
     
    \item \hfill 
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, below of=q0, accepting] {$q_3$};
        \node (q4) [state, right of=q3] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$a$} (q1)
        (q1) edge node [above] {$b$} (q2)
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [bend right=75] node [above] {$a$} (q0)
        (q2) edge node [below] {$b$} (q4)
        (q3) edge node [left] {$b$} (q0)
        (q3) edge node [above] {$a$} (q1)
        (q4) edge node [left] {$b$} (q1)
        (q4) edge [loop right] node [right] {$a$} ()
        (q4) edge node [below] {$a$} (q3);   
        \end{tikzpicture}
            \end{center} 
    Como el grafo de M ya esta en su forma GEC procedemos con el algoritmo:
    \begin{itemize}
        \item[i)] Eliminar estado $q_2$:
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 4cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q3) [state, below of=q0, accepting] {$q_3$};
            \node (q4) [state, right of=q3] {$q_4$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [loop above] node [above] {$b$} ()
            (q1) edge [bend left] node [below] {$ba$} (q0)
            (q1) edge [bend right] node [left] {$b^2$} (q4) 
            (q3) edge node [left] {$b$} (q0)
            (q3) edge node [above] {$a$} (q1)
            (q4) edge [loop right] node [right] {$a$} ()
            (q4) edge node [below] {$a$} (q3)
            (q4) edge [bend right] node [right] {$b$} (q1);     
            \end{tikzpicture}
        \end{basedtikz}
        \item[ii)] Eliminar estado $q_4$:
         
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 4cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q3) [state, below of=q0, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [loop above] node [above] {$b\cup b^2a^*b$} ()
            (q1) edge [bend left] node [below] {$ba$} (q0) 
            (q1) edge [bend left] node [right] {$b^2a^*a$} (q3)
            (q3) edge node [left] {$b$} (q0)
            (q3) edge node [above] {$a$} (q1);     
            \end{tikzpicture}
        \end{basedtikz}
        \item[iii)] Agregamos un nuevo estado de aceptación $q$:
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 4cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q3) [state, below of=q0] {$q_3$};
            \node (q) [state, right of=q3, accepting] {$q$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [loop above] node [above] {$b\cup b^2a^*b$} ()
            (q1) edge [bend left] node [below] {$ba$} (q0) 
            (q1) edge [bend left] node [right] {$b^2a^*a$} (q3)
            (q3) edge node [left] {$b$} (q0)
            (q3) edge node [above] {$a$} (q1)
            (q1) edge node [right] {$\lambda$} (q)
            (q3) edge node [below] {$\lambda$} (q);     
            \end{tikzpicture}
        \end{basedtikz}
        \item[iv)] Eliminar estado $q_3$:
         
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 4cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q) [state, below of=q1, accepting] {$q$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [loop above] node [above] {$b\cup b^2a^*b\cup b^2a^*a^2$} ()
            (q1) edge [bend left] node [below] {$ba\cup b^2a^*ab$} (q0) 
            (q1) edge node [right] {$\lambda\cup b^2a^*a$} (q);     
            \end{tikzpicture}
        \end{basedtikz}
        \item[v)] Eliminar estado $q_1$:
        \begin{basedtikz}
        \centering
            \begin{tikzpicture}[node distance = 6cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q) [state, right of=q0, accepting] {$q$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a[b\cup b^2a^*b\cup b^2a^*a^2]^*(\lambda\cup b^2a^*a)$} (q)
            (q0) edge [loop below] node [below] {$a[b\cup b^2a^*b\cup b^2a^*a^2]^*[ba\cup b^2a^*ab]$} ();     
            \end{tikzpicture}
        \end{basedtikz}
    \end{itemize}
    Luego por simple inspección obtenemos que:
    $$L(M)=\left(a[b\cup b^2a^*b\cup b^2a^*a^2]^*[ba\cup b^2a^*ab]\right)^*a[b\cup b^2a^*b\cup b^2a^*a^2]^*(\lambda\cup b^2a^*a)$$
\end{itemize}
\textbf{Punto 2: } Sea $\Sigma=\{a,b,c\}$ y $L$ el lenguaje de todas las cadenas que no contienen la subcadena $bc.$ Diseñar un autómata $M$ que acepte el lenguaje $L$, y luego utilizar el procedimiento presentado en la presente sección para encontrar una expresión regular para $L.$\\

Primero hagamos el grafo de todas las cadenas que contienen la subcadena $bc$:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a,c$} () 
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [loop above] node [above] {$b$} ()
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q1) edge node [above] {$c$} (q2)
        (q2) edge [loop above] node [above] {$a,b,c$} ();
    \end{tikzpicture}
\end{basedtikz}
Note que este es un AFD por lo tanto basta considerar el complemento del mismo para obtener el grafo de todas las cadenas que no contienen la subcadena $bc:$
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a\cup c$} () 
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [loop above] node [above] {$b$} ()
        (q1) edge [bend left] node [below] {$a$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Note que nos saltamos algunos pasos de simplificación ya que al tomar el complemento, el estado $q_2$ se vuelve un estado limbo y puede ser eliminado. Ademas ya expresamos el grafo $M$ en su forma GEC por lo que podemos proceder con el algoritmo:
\begin{itemize}
    \item[i)] Agregar nuevo estado de aceptación $q$: 
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q) [state, below of=q1, accepting] {$q$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a\cup c$} () 
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [loop above] node [above] {$b$} ()
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q0) edge node [left] {$\lambda$} (q)
        (q1) edge node [right] {$\lambda$} (q);
    \end{tikzpicture}
\end{basedtikz}
    \item[ii)] Eliminar estado $q_1$:
    \begin{basedtikz}
    \centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q) [state, right of=q0, accepting] {$q$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a\cup c\cup bb^*a$} () 
        (q0) edge node [above] {$\lambda\cup bb^*$} (q);
    \end{tikzpicture}
\end{basedtikz}
\end{itemize}
Ahora por simple inspección podemos observar que:
$$L=L(M)=(a\cup c\cup bb^*a)^*(\lambda\cup bb^*)$$
Este seria el lenguaje de todas las cadenas que no contienen la subcadena $bc$. Note que si realizamos las simplificaciones $bb^*=b^+$ y $\lambda\cup bb^*=\lambda\cup b^+=b^*$ obtenemos que: 
$$L=(a\cup c\cup b^+a)^*b^*$$
Note que la expresión encontrada es idéntica a una de las expresiones brindadas por las notas en el ultimo ejemplo de la sección 2.2.\\ 

\textbf{Punto 3: } Sea $\Sigma=\{a,b\}$ y $L=\{u\in\Sigma^*:[\#_a(u)-\#_b(u)]\equiv 1(\mod3) \}.$ La notación $\#_a(u)$ representa el numero de $aes$ en la cadena $u$ mientras que $\#_b(u)$ es el numero de $bes.$ Diseñar un AFD $M$ con tres estados que acepte el lenguaje $L,$ y luego utilizar el procedimiento presentado en la presente sección para encontrar una expresión regular para $L.$\\ 

Como estamos restringidos a tres estados basta por medio de cadenas básicas intuir como son las transiciones para $M$:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, , accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1) 
        (q1) edge [bend left] node [above] {$a$} (q2)
        (q2) edge [bend left=60] node [below] {$a$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Note que si la cadena tiene solo $aes$ basta con ver que el numero sea congruente con 1 modulo 3, y por eso tenemos ese bucle donde cada estado representa la congruencia y es por eso que $q_1$ es nuestro estado de aceptación. Ahora solo falta ver que pasa con las transiciones para las $bes$ pero esto es sencillo de ver si consideramos cadenas que solo tienen $bes$ a que numero serian congruentes:
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, , accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1) 
        (q1) edge [bend left] node [above] {$a$} (q2)
        (q2) edge [bend left=60] node [below] {$a$} (q0)
        (q2) edge [bend left] node [below] {$b$} (q1)
        (q1) edge [bend left] node [below] {$b$} (q0)
        (q0) edge [bend left=60] node [above] {$b$} (q2);
    \end{tikzpicture}
\end{basedtikz}
Este seria nuestro grafo de $M$ que acepta $L$;  como ya esta en su forma GEC podemos eliminar el estado $q_2$ según el algoritmo presentado:
 
\begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, , accepting] {$q_1$};
        \path[thick]
        (q0) edge [loop above] node [above] {$ba$} ()
        (q0) edge [bend left] node [above] {$a\cup b^2$} (q1) 
        (q1) edge [loop above] node [above] {$ab$} ()
        (q1) edge [bend left] node [below] {$b\cup a^2$} (q0);
    \end{tikzpicture}
\end{basedtikz}
De aquí ya por simple inspección podemos observar que la expresión regular para $L$ es:
$$L=L(M)=(ba)^*(a\cup b^2)(ab\cup(b\cup a^2)(ba)^*(a\cup b^2))^*$$
$\hfill \blacklozenge$

\section{Teorema de Myhill-Nerode}

Esta sección es completamente opcional ya que Korgi no la trata a profundidad, pero puede que algún profesor si lo haga así que haremos las demostraciones correspondientes.\\

\textbf{Punto 1: }Sea $\Sigma$ un alfabeto dado, $L\subseteq\Sigma^*$ y $I_L$ la relación de indistinguibilidad definida sobre $\Sigma^*.$ Para cada $u\in\Sigma^*,\,[u]$ denota la clase de equivalencia de $u,$ determinada por $I_L.$ Demostrar que para todo $u,v\in\Sigma^*$ se cumple
\begin{itemize}
    \item[$\bullet$] Si $u\in L$ y $v\in[u]$ entonces $v\in L.$
    \begin{proof}
        Como $v\in[u],$ por la definición de $I_L$ tenemos que para todo $x\in\Sigma^*,$ $ux\in L$ si y solo si $vx\in L.$ Particularmente si $x=\lambda$ y como $u\in L$, podemos concluir que $v\in L.$ 
    \end{proof}
    \item[$\bullet$] Si $uI_Lv$ entonces $uaI_Lva,$ para todo $a\in Sigma.$
    \begin{proof}
        Sea $a\in\Sigma,$ recordemos que $\Sigma\subset\Sigma^*,$ así $a\in\Sigma^*.$ Luego por hipótesis como $uI_Lv$ tenemos que para todo $x\in\Sigma^*,$ $ux\in L$ si y solo si $vx\in L.$ Note que en particular $x=ay$ donde $y\in\Sigma^*$, pero este $y$ es arbitrario, así que podemos decir que para todo $y\in\Sigma^*,$ $uay\in L$ si y solo si $vay\in L.$ que es lo mismo que decir $uaI_Luv.$
    \end{proof}
\end{itemize}

\textbf{Punto 2: }Demostrar la afirmación (2.15.4) de la demostración del Teorema de Myhill-Nerode, esto es, demostrar por recursión sobre $u$, que
$$\widehat{\delta_L}([\lambda],u)=[u]\text{, para toda cadena }u\in\Sigma^*.$$
\begin{proof}
    Para el caso $u=\lambda$ tenemos por definición
    $$\widehat{\delta_L}([\lambda],\lambda)=[\lambda]$$
    Note de manera similar que para el caso $u=a$ con $a\in\Sigma$ tenemos que
    $$\widehat{\delta_L}([\lambda],a)=[a]$$
    Ahora supongamos que $\widehat{\delta_L}([\lambda],u)=[u]$ y veamos que pasa con $ua$
    \begin{align*}
       \widehat{\delta_L}([\lambda],ua)&=\widehat{\delta_L}(\widehat{\delta_L}([\lambda],u),a)&&\text{(Propiedad función de transición)}\\
       &=\widehat{\delta_L}([u],a)&&\text{(Hipótesis recursiva)} \\
       &=[ua]&&\text{(Definición de la función de transición).}
    \end{align*}
Así podemos concluir que para toda cadena $u\in\Sigma^*$ tenemos que $\widehat{\delta_L}([\lambda],u)=[u].$
\end{proof}
\textbf{Punto 3: }Demostrar que la función $f:Q\to Q_L$ definida en la demostración del Teorema 2.15.4 satisface las propiedades (1) y (2) de la Definición 2.15.5.
\begin{itemize}
    \item[$\bullet$]$f(q_0)=q_i.$
\begin{proof}
    Por definición de $f$ tenemos que:
    $$f(q_0)=[u]$$ 
    donde $\widehat{\delta}(q_0,u)=q_0$ para alguna cadena $u\in\Sigma^*,$ pero note que $\widehat{\delta}(q_0,\lambda)=q_0$ para cualquier autómata arbitrario $M$, así $f(q_0)=[\lambda]$ y como $[\lambda]=q_i$, hemos mostrado que $f(q_0)=q_i$. 
\end{proof}
    \item[$\bullet$]$q\in F$ si y solo si $f(q)\in F_L.$
    \begin{proof}
        ($\Rightarrow$) Si $q\in F$, luego $f(q)=[u]$ donde $\widehat{\delta}(q_0,u)=q$, pero como $q\in F$ quiere decir que el $u\in L$ y por definición de $F_L$ concluimos que $f(q)=[u]\in F_L.$\\
        ($\Leftarrow$) Si $f(q)\in F_L$ quiere decir que $f(q)=[u]$ donde $u\in L$, pero como por definición de $f$, $\widehat{\delta}(q_0,u)=q$ quiere decir que $q$ es un estado de aceptación, y por tanto $q\in F.$
    \end{proof}
\end{itemize}
$\hfill \blacklozenge$
\section{Algoritmo de minimización de AFDs}

En esta sección el propósito sera hallar el autómata con el mínimo numero de estados que acepte un lenguaje en particular. Note que este procedimiento siempre lo haremos partiendo de un AFD que acepte el lenguaje para ver si podemos minimizar el numero de estados o si precisamente ese es el mínimo.\\

\textbf{Punto 1: }Minimizar los siguientes $AFD,$ es decir, encontrar autómatas deterministas con el mínimo numero de estados posible, equivalentes a los autómatas dados.
\begin{itemize}
    \item[$\bullet$] Alfabeto $\Sigma=\{a,b\}.$
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q3) [state, right of=q1] {$q_3$};
            \node (q2) [state, above right of=q3] {$q_2$};
            \node (q6) [state, below right of=q3] {$q_6$};
            \node (q5) [state, above right of=q6, accepting] {$q_5$};
            \path[thick]
            (q0) edge [loop above] node [above] {$b$} ()
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$a$} (q2)
            (q1) edge [bend right] node [below] {$b$} (q6)
            (q3) edge node [above] {$a,b$} (q1)
            (q2) edge node [above] {$b$} (q3)
            (q2) edge node [above] {$a$} (q5)
            (q6) edge node [below] {$b$} (q3)
            (q6) edge node [below] {$a$} (q5)
            (q5) edge [bend left=45] node [below] {$a$} (q6)
            (q5) edge [bend right=45] node [above] {$b$} (q2);
            \end{tikzpicture}
            \end{center} 
    Para la iteración $i=1,$ marcamos con $\times$ las casillas de estados $\{p,q\}$  donde $p$ es de aceptación y $q$ no, o viceversa:
    \begin{center}
        \begin{tabular}{ cccccc}
        $q_0$& & & & & \\ \cline{1-1}
        \multicolumn{1}{|c|}{$\times$} &$q_1$ & & & & \\ \cline{1-2}
        \multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &$q_2$ & & & \\ \cline{1-3}
        \multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &$q_3$ & & \\ \cline{1-4}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_5$ & \\ \cline{1-5}
        \multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &$q_6$ \\ \cline{1-5}
    \end{tabular}
    \end{center}
    Ahora para $i=2$, examinamos las parejas de casillas no marcadas y sus transiciones:
    \begin{center}
        \begin{tabular}{c||c|c}
        $\{p,q\}$ & $\{\delta(p,a),\delta(q,a)\}$ & $\{\delta(p,b),\delta(q,b)\}$ \\ \hline
        $\{q_0,q_2\}$ & $\{q_1,q_5\}$ & $\{q_0,q_3\}$ \\ \hline
        $\{q_0,q_3\}$ & $\{q_1,q_1\}$ & $\{q_0,q_1\}\times$ \\ \hline
        $\{q_0,q_6\}$ & $\{q_1,q_5\}$ & $\{q_0,q_3\}$ \\ \hline
        $\{q_1,q_5\}$ & $\{q_2,q_6\}$ & $\{q_6,q_2\}$ \\ \hline
        $\{q_2,q_3\}$ & $\{q_5,q_1\}\times$ & $\{q_3,q_1\}\times$ \\ \hline
        $\{q_2,q_6\}$ & $\{q_5,q_5\}$  & $\{q_3,q_3\}$ \\ \hline
        $\{q_3,q_6\}$ & $\{q_1,q_5\}$ & $\{q_1,q_3\}\times$ \\ \hline   
        \end{tabular}
    \end{center}
    Note que marcamos con $\times$ aquellos pares que tenían este símbolo en $i=1.$ Siguiendo con el algoritmo, los pares que tengan alguna $\times$ en su fila deberán ser marcados también:
    \begin{center}
        \begin{tabular}{ cccccc}
        $q_0$& & & & & \\ \cline{1-1}
        \multicolumn{1}{|c|}{$\times$} &$q_1$ & & & & \\ \cline{1-2}
        \multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &$q_2$ & & & \\ \cline{1-3}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_3$ & & \\ \cline{1-4}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_5$ & \\ \cline{1-5}
        \multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_6$ \\ \cline{1-5}
    \end{tabular}
    \end{center}
    Para $i=3$ volvemos a repetir el procedimiento con las casillas que aun no han sido marcadas:
    \begin{center}
        \begin{tabular}{c||c|c}
        $\{p,q\}$ & $\{\delta(p,a),\delta(q,a)\}$ & $\{\delta(p,b),\delta(q,b)\}$ \\ \hline
        $\{q_0,q_2\}$ & $\{q_1,q_5\}$ & $\{q_0,q_3\}\times$ \\ \hline
        $\{q_0,q_6\}$ & $\{q_1,q_5\}$ & $\{q_0,q_3\}\times$ \\ \hline
        $\{q_1,q_5\}$ & $\{q_2,q_6\}$ & $\{q_6,q_2\}$ \\ \hline
        $\{q_2,q_6\}$ & $\{q_5,q_5\}$  & $\{q_3,q_3\}$ \\ \hline  
        \end{tabular}
    \end{center}
    y por el algoritmo nos queda la siguiente tabla:
    \begin{center}
        \begin{tabular}{ cccccc}
        $q_0$& & & & & \\ \cline{1-1}
        \multicolumn{1}{|c|}{$\times$} &$q_1$ & & & & \\ \cline{1-2}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_2$ & & & \\ \cline{1-3}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_3$ & & \\ \cline{1-4}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_5$ & \\ \cline{1-5}
        \multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{} &\multicolumn{1}{|c|}{$\times$} &\multicolumn{1}{|c|}{$\times$} &$q_6$ \\ \cline{1-5}
    \end{tabular}
    \end{center}
    Ahora para $i=4$ observe que no se pueden marcar mas casillas, de esta manera obtenemos que $q_1\approx q_5$ y $q_2\approx q_6.$ Luego el autómata cociente tiene los estados $\{q_0\},\{q_3\},\{q_1,q_5\}$ y $\{q_2,q_6\}.$ De esta manera el grafo del autómata minimizado es el siguiente:
    \pagebreak
    \begin{basedtikz}
\centering
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$\{q_0\}$};
        \node (q15) [state, right of=q0, accepting] {$\{q_1,q_5\}$};
        \node (q26) [state, right of=q15] {$\{q_2,q_6\}$};
        \node (q3) [state, right of=q26] {$\{q_3\}$};
        \path[thick]
        (q0) edge [loop above] node [above] {$b$} ()
        (q15) edge [bend left] node [above] {$a,b$} (q26)
        (q26) edge [bend left] node [below] {$a$} (q15)
        (q26) edge node [above] {$b$} (q3)
        (q3) edge [bend left=60] node [below] {$a,b$} (q15)
        (q0) edge node [above] {$a$} (q15);
        \end{tikzpicture}
\end{basedtikz}
    \item[$\bullet$]Alfabeto $\Sigma=\{a,b\}.$
    \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q3) [state, right of=q1] {$q_3$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \node (q4) [state, right of=q2] {$q_4$};
            \node (q5) [state, above right of=q4, accepting] {$q_5$};
            \node (q6) [state, right of=q5] {$q_6$};
            
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q0) edge node [below] {$b$} (q2)
            (q1) edge node [above] {$a$} (q3)
            (q1) edge node [right] {$b$} (q4)
            (q2) edge node [below] {$a$} (q4)
            (q2) edge node [left] {$b$} (q3)
            (q3) edge node [above] {$b$} (q5)
            (q4) edge node [below] {$b$} (q5)
            (q3) edge node [above] {$a$} (q6)
            (q4) edge node [below] {$a$} (q6)
            (q5) edge node [above] {$a,b$} (q6)
            (q6) edge [loop above] node [above] {$a,b$} ();
            \end{tikzpicture}
            \end{center} 
        Para la iteración $i=1$ tenemos que:
        \begin{center}
            \begin{tabular}{ccccccc}
            $q_0$ \\ \cline{1-1}
            \multicolumn{1}{|c|}{$\times$} & $q_1$ \\ \cline{1-2}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_2$ \\ \cline{1-3}
            \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_3$ \\ \cline{1-4}
            \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_4$ \\ \cline{1-5}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\
            \cline{1-6}
            \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\
            \cline{1-6}   
            \end{tabular}
        \end{center}
        Ahora en $i=2$ examinamos las parejas de estados que no fueron tachadas:
        \begin{center}
            \begin{tabular}{c||c|c}
            $\{p,q\}$ & $\{\delta(p,a),\delta(q,a\}$ & $\{\delta(p,b),\delta(q,b\}$\\
            \hline
            $\{q_0,q_3\}$ & $\{q_1,q_6\}\times$ & $\{q_2,q_5\}$ \\
            \hline
            $\{q_0,q_4\}$ & $\{q_1,q_6\}\times$ & $\{q_2,q_5\}$ \\
            \hline
            $\{q_0,q_6\}$ & $\{q_1,q_6\}\times$ & $\{q_2,q_6\}\times$ \\
            \hline
            $\{q_1,q_2\}$ & $\{q_3,q_4\}$ & $\{q_4,q_3\}$ \\
            \hline
            $\{q_1,q_5\}$ & $\{q_3,q_6\}$ & $\{q_4,q_6\}$ \\
            \hline
            $\{q_2,q_5\}$ & $\{q_4,q_6\}$ & $\{q_3,q_6\}$ \\
            \hline
            $\{q_3,q_4\}$ & $\{q_6,q_6\}$ & $\{q_5,q_5\}$\\
            \hline
            $\{q_3,q_6\}$ & $\{q_6,q_6\}$ & $\{q_5,q_6\}\times$\\
            \hline
            $\{q_4,q_6\}$ & $\{q_6,q_6\}$ & $\{q_5,q_6\}\times$\\
            \hline
            \end{tabular}
        \end{center}
        Siguiendo el algoritmo tachamos las casillas marcadas en la tabla:
        \begin{center}
            \begin{tabular}{ccccccc}
            $q_0$ \\ \cline{1-1}
            \multicolumn{1}{|c|}{$\times$} & $q_1$ \\
             \cline{1-2}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_2$ \\ \cline{1-3}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_3$ \\
             \cline{1-4}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_4$ \\ \cline{1-5}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\
            \cline{1-6}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\
            \cline{1-6}   
            \end{tabular}
        \end{center}
    Ahora para $i=3$ estudiamos las casillas no tachadas en el anterior paso:
    \begin{center}
            \begin{tabular}{c||c|c}
            $\{p,q\}$ & $\{\delta(p,a),\delta(q,a\}$ & $\{\delta(p,b),\delta(q,b\}$\\
            \hline
            $\{q_1,q_2\}$ & $\{q_3,q_4\}$ & $\{q_4,q_3\}$ \\
            \hline
            $\{q_1,q_5\}$ & $\{q_3,q_6\}\times$ & $\{q_4,q_6\}\times$ \\
            \hline
            $\{q_2,q_5\}$ & $\{q_4,q_6\}\times$ & $\{q_3,q_6\}\times$ \\
            \hline
            $\{q_3,q_4\}$ & $\{q_6,q_6\}$ & $\{q_5,q_5\}$\\
            \hline
            \end{tabular}
        \end{center}
    De esta forma tenemos que tachar las siguientes casillas:
    \begin{center}
            \begin{tabular}{ccccccc}
            $q_0$ \\ \cline{1-1}
            \multicolumn{1}{|c|}{$\times$} & $q_1$ \\
             \cline{1-2}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_2$ \\ \cline{1-3}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_3$ \\
             \cline{1-4}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_4$ \\ \cline{1-5}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\
            \cline{1-6}
            \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\
            \cline{1-6}   
            \end{tabular}
        \end{center}
        Note que para $i=4$ ya no podemos tachar casillas nuevas, así $q_1\approx q_2$ y $q_3\approx q_4.$ Luego el autómata cociente tiene los estados $\{q_0\},\{q_1,q_2\},\{q_3,q_4\},\{q_5\}$ y $\{q_6\}.$ De esta manera obtenemos que el grafo autómata minimizado es:
        \begin{basedtikz}
        \centering
        \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q0) [state, initial] {$\{q_0\}$};
        \node (q12) [state, right of=q0, accepting] {$\{q_1,q_2\}$};
        \node (q34) [state, right of=q12] {$\{q_3,q_4\}$};
        \node (q5) [state, right of=q34, accepting] {$\{q_5\}$};
        \path[thick]
        (q0) edge node [above] {$a,b$} (q12)
        (q12) edge node [above] {$a,b$} (q34)
        (q34) edge node [above] {$b$} (q5);
        \end{tikzpicture}
        \end{basedtikz}
        Note que simplificamos el grafo ya que $\{q_6\}$ actuá como limbo al igual que en el autómata original, pero recordemos que para el proceso de minimización es importante tener \textbf{TODOS} los estados en consideración y por eso al principio es ilustrado en el grafo para mayor claridad.
        \item[$\bullet$] Alfabeto $\Sigma=\{a,b\}.$
        \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting ] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \node (q4) [state, below of=q0] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$};
            \node (q6) [state, below of=q2] {$q_6$};
            \node (q7) [state, below of=q3] {$q_7$};
            
            \path[thick]
            (q0) edge node [above] {$b$} (q1)
            (q0) edge node [left] {$a$} (q4)
            (q1) edge node [above] {$a$} (q2)
            (q1) edge node [right] {$b$} (q5)
            (q2) edge node [left] {$a$} (q6)
            (q2) edge node [above] {$b$} (q3)
            (q3) edge [bend right] node [left] {$a$} (q7)
            (q3) edge [loop above] node [above] {$b$} ()
            (q4) edge [loop below] node [below] {$a$} ()
            (q4) edge [bend left] node [above] {$b$} (q5)
            (q5) edge [bend left] node [below] {$a$} (q4)
            (q5) edge [loop below] node [below] {$b$} ()
            (q6) edge [bend left] node [above] {$a$} (q7)
            (q6) edge node [above] {$b$} (q3)
            (q7) edge [bend left] node [below] {$a$} (q6)
            (q7) edge [bend right] node [right] {$b$} (q3);
            \end{tikzpicture}
            \end{center} 
            Para la iteración $i=1$ tenemos
            \begin{center}
                \begin{tabular}{cccccccc}
                   $q_0$ \\ \cline{1-1}
                   \multicolumn{1}{|c|}{} & $q_1$ \\ \cline{1-2}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_2$ \\ \cline{1-3}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_3$\\ \cline{1-4}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & $q_4$ \\ \cline{1-5}
                   \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\ \cline{1-6}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\ \cline{1-7}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_7$ \\ \cline{1-7}
                \end{tabular}
            \end{center}
            Ahora en $i=2$ examinamos las parejas de estados no tachadas:
            \begin{center}
                \begin{tabular}{c||c|c}
                  $\{p,q\}$ & $\{\delta(p,a),\delta(q,a)\}$ & $\{\delta(p,b),\delta(q,b)\}$\\ \hline
                  $\{q_0,q_1\}$ & $\{q_4,q_2\}$ & $\{q_1,q_5\}$ \\ \hline
                  $\{q_0,q_5\}$ & $\{q_4,q_4\}$ & $\{q_1,q_5\}$ \\ \hline
                  $\{q_1,q_5\}$ & $\{q_2,q_4\}$ & $\{q_5,q_5\}$ \\ \hline
                  $\{q_2,q_3\}$ & $\{q_6,q_7\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_2,q_4\}$ & $\{q_6,q_4\}$ & $\{q_3,q_5\}\times$ \\ \hline
                  $\{q_2,q_6\}$ & $\{q_6,q_7\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_2,q_7\}$ & $\{q_6,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_3,q_4\}$ & $\{q_7,q_4\}$ & $\{q_3,q_5\}\times$ \\ \hline
                  $\{q_3,q_6\}$ & $\{q_7,q_3\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_3,q_7\}$ & $\{q_7,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_4,q_6\}$ & $\{q_4,q_7\}$ & $\{q_5,q_3\}\times$ \\ \hline
                  $\{q_4,q_7\}$ & $\{q_4,q_6\}$ & $\{q_5,q_3\}\times$ \\ \hline
                  $\{q_6,q_7\}$ & $\{q_7,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                \end{tabular}
            \end{center}
            Siguiendo el algoritmo
            \begin{center}
                \begin{tabular}{cccccccc}
                   $q_0$ \\ \cline{1-1}
                   \multicolumn{1}{|c|}{} & $q_1$ \\ \cline{1-2}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_2$ \\ \cline{1-3}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_3$\\ \cline{1-4}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_4$ \\ \cline{1-5}
                   \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\ \cline{1-6}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\ \cline{1-7}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_7$ \\ \cline{1-7}
                \end{tabular}
            \end{center}
            Ahora para $i=3$, tenemos:
            \begin{center}
                \begin{tabular}{c||c|c}
                  $\{p,q\}$ & $\{\delta(p,a),\delta(q,a)\}$ & $\{\delta(p,b),\delta(q,b)\}$\\ \hline
                  $\{q_0,q_1\}$ & $\{q_4,q_2\}\times$ & $\{q_1,q_5\}$ \\ \hline
                  $\{q_0,q_5\}$ & $\{q_4,q_4\}\times$ & $\{q_1,q_5\}$ \\ \hline
                  $\{q_1,q_5\}$ & $\{q_2,q_4\}\times$ & $\{q_5,q_5\}$ \\ \hline
                  $\{q_2,q_3\}$ & $\{q_6,q_7\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_2,q_6\}$ & $\{q_6,q_7\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_2,q_7\}$ & $\{q_6,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_3,q_6\}$ & $\{q_7,q_3\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_3,q_7\}$ & $\{q_7,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                  $\{q_6,q_7\}$ & $\{q_7,q_6\}$ & $\{q_3,q_3\}$ \\ \hline
                \end{tabular}
            \end{center}
            y siguiendo el algoritmo
            \begin{center}
                \begin{tabular}{cccccccc}
                   $q_0$ \\ \cline{1-1}
                   \multicolumn{1}{|c|}{$\times$} & $q_1$ \\ \cline{1-2}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_2$ \\ \cline{1-3}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_3$\\ \cline{1-4}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_4$ \\ \cline{1-5}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\ \cline{1-6}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & $q_6$ \\ \cline{1-7}
                   \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_7$ \\ \cline{1-7}
                \end{tabular}
            \end{center}
            Note que para $i=4$ ya no podemos tachar mas casillas, así $q_2\approx q_3 \approx q_6 \approx q_7.$ Luego el autómata cociente tiene los estados $\{q_0\},\{q_1\},\{q_4\}, \{q_5\}$ y $\{q_2,q_3,q_6,q_7\}.$ De esta manera el grafo del autómata minimizado es
            
         \begin{basedtikz}
             \centering
             \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting ] {$\{q_0\}$};
            \node (q1) [state, right of=q0, accepting] {$\{q_1\}$};
            \node (q4) [state, below of=q0] {$\{q_4\}$};
            \node (q5) [state, right of=q4, accepting] {$\{q_5\}$};
            \path[thick]
            (q0) edge node [above] {$b$} (q1)
            (q0) edge node [left] {$a$} (q4)
            (q1) edge node [right] {$b$} (q5)
            (q4) edge [loop below] node [below] {$a$} ()
            (q4) edge [bend left] node [above] {$b$} (q5)
            (q5) edge [bend left] node [below] {$a$} (q4)
            (q5) edge [loop below] node [below] {$b$} ();
            \end{tikzpicture}
         \end{basedtikz}

         Note que esta minimización tiene bastante sentido, ya que por simple inspección podemos notar que toda la parte derecha conectada a $q_2$ actuá como un limbo, así que puede ser borrado, por esto mismo, en la presentación del grafo minimizado omitimos el estado $\{q_2,q_3,q_6,q_7\}.$

         \item[$\bullet$] Alfabeto $\Sigma=\{0,1\}.$

         \begin{center}
         \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting ] {$q_0$};
            \node (q1) [state, above right of=q0] {$q_1$};
            \node (q3) [state, below right of=q0] {$q_3$};
            \node (q4) [state, above right of=q3, accepting] {$q_4$};
            \node (q2) [state, above right of=q4] {$q_2$};
            \node (q5) [state, below right of=q4] {$q_5$};
            \path[thick]
            (q0) edge node [above] {$1$} (q1)
            (q0) edge node [below] {$0$} (q3)
            (q1) edge [loop above] node [above] {$1$} ()
            (q1) edge node [above] {$0$} (q4)
            (q2) edge node [above] {$1$} (q1)
            (q2) edge [bend left] node [below] {$0$} (q4)
            (q3) edge [loop below] node [below] {$1$} ()
            (q3) edge node [above] {$0$} (q4)
            (q4) edge [bend left] node [above] {$1$} (q2)
            (q4) edge [bend right] node [below] {$0$} (q5)
            (q5) edge node [below] {$1$} (q3)
            (q5) edge [bend right] node [above] {$0$} (q4);
            \end{tikzpicture}
            \end{center} 
            Para la iteración $i=1$, tenemos
            \begin{center}
                 \begin{tabular}{cccccc}
                    $q_0$ \\ \cline{1-1}
                    \multicolumn{1}{|c|}{$\times$} & $q_1$ \\ \cline{1-2}
                    \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & $q_2$ \\ \cline{1-3}
                    \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & $q_3$ \\ \cline{1-4}
                    \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{$\times$}& \multicolumn{1}{|c|}{$\times$}& $q_4$ \\ \cline{1-5}
                    \multicolumn{1}{|c|}{$\times$} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{$\times$} & $q_5$ \\ \cline{1-5}
                 \end{tabular}
             \end{center}
             Para $i=2$ examinamos las parejas no tachadas
             \begin{center}
                \begin{tabular}{c||c|c}
                  $\{p,q\}$ & $\{\delta(p,0),\delta(q,0)\}$ & $\{\delta(p,1),\delta(q,1)\}$\\ \hline
                  $\{q_0,q_4\}$ & $\{q_3,q_5\}$ & $\{q_1,q_2\}$ \\ \hline
                  $\{q_1,q_2\}$ & $\{q_4,q_4\}$ & $\{q_1,q_1\}$ \\ \hline
                  $\{q_1,q_3\}$ & $\{q_4,q_4\}$ & $\{q_1,q_3\}$ \\ \hline
                  $\{q_1,q_5\}$ & $\{q_4,q_4\}$ & $\{q_1,q_3\}$ \\ \hline
                  $\{q_2,q_3\}$ & $\{q_4,q_4\}$ & $\{q_1,q_3\}$ \\ \hline
                  $\{q_2,q_5\}$ & $\{q_4,q_4\}$ & $\{q_1,q_3\}$ \\ \hline
                  $\{q_3,q_5\}$ & $\{q_4,q_4\}$ & $\{q_3,q_3\}$ \\ \hline
                \end{tabular}
            \end{center}
            Note que curiosamente no podemos tachar ninguna casilla nueva, por lo que $q_0 \approx q_4$ y $q_1\approx q_2\approx q_3\approx q_5,$ luego el grafo del autómata minimizado esta dado por
            \begin{basedtikz}
             \centering
             \begin{tikzpicture}[node distance = 5cm, on grid, auto]
            \node (q0) [state, initial, accepting ] {$\{q_0,q_4\}$};
            \node (q1) [state, right of=q0] {$\{q_1,q_2,q_3,q_5\}$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0,1$} (q1)
            (q1) edge [bend left] node [below] {$0$} (q0)
            (q1) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
         \end{basedtikz}

        \item[$\bullet$] Alfabeto $\Sigma=\{a,b,c\}.$

        \item[$\bullet$] El siguiente autómata fue obtenido utilizando el producto cartesiano para aceptar el lenguaje $L$ de todas las cadenas sobre el alfabeto $\Sigma=\{a,b\}$ que tienen longitud impar o que no contienen dos $b$es consecutivas.
\end{itemize}

\textbf{Punto 2: } Sea $\Sigma=\{a,b\}.$ Demostrar que el lenguaje $L=a^+b^*a$ no puede ser aceptado por ningún AFD con menos de seis estados (incluyendo el estado limbo).\\

\textbf{Punto 3: } Sea $\Sigma=\{a,b\}.$ Demostrar que el lenguaje $L=a^*b\cup b^*a$ no puede ser aceptado por ningún AFD con menos de siete estados (incluyendo el estado limbo).\\

\textcolor{blue}{Ya casi termino este capitulo 2 de mierda, vaina tan eterna :p}
